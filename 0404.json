[
    {
        "commit_message": "add more chord data",
        "added_files": {},
        "modified_files": {
            "src/data/chords.js": "/*\n  和弦按法数据\n\n  chordData 是一个对象，每个键值对表示一个和弦，\n  键是和弦名称（例如 F, G, C）\n  值是一个对象，包含每根弦的按法，以及大横按等。\n\n  position: 定义高把位和弦位置，\n  例如： 4 \n  表示： 和弦图从第4品开始\n\n  chord: 定义每根弦的按法，\n  例如： [[1, 0], [2, 1], [3, 2], [4, 2], [5, 0], [6, 'x']] \n  表示： 1弦空弦，2弦1品，3弦2品，4弦2品，5弦空弦，6弦不发音\n\n  barres: 定义大横按，\n  例如： [{ fromString: 6, toString: 1, fret: 1 }] \n  表示： 大横按从6弦到1弦，在1品按住\n*/\nexport const chordData = {\n  C: {\n    chord: [[1, 0], [2, 1], [3, 0], [4, 2], [5, 3], [6, 'x']],\n  },\n  \n  Cmaj7: {\n    chord: [[1, 0], [2, 0], [3, 0], [4, 2], [5, 3], [6, 'x']],\n  },\n  \n  C7: {\n    chord: [[1, 0], [2, 1], [3, 3], [4, 2], [5, 3], [6, 'x']],\n  },\n  \n  Cm: {\n    position: 3,\n    chord: [[1, 1], [2, 1], [3, 1], [4, 3], [5, 3], [6, 'x']],\n    barres: [\n      { fromString: 5, toString: 1, fret: 1 },\n    ],\n  },\n  \n  \"C#\": {\n    position: 4,\n    chord: [[1, 1], [2, 1], [3, 1], [4, 3], [5, 4], [6, 'x']],\n    barres: [\n      { fromString: 5, toString: 1, fret: 1 },\n    ],\n  },\n  \n  \"C#m\": {\n    position: 4,\n    chord: [[1, 1], [2, 2], [3, 3], [4, 3], [5, 1], [6, 'x']],\n    barres: [\n      { fromString: 5, toString: 1, fret: 1 },\n    ],\n  },\n  \n  \"C#m7\": {\n    position: 4,\n    chord: [[1, 1], [2, 2], [3, 1], [4, 3], [5, 1], [6, 'x']],\n    barres: [\n      { fromString: 5, toString: 1, fret: 1 },\n    ],\n  },\n  \n  D: {\n    chord: [[1, 2], [2, 3], [3, 2], [4, 0], [5, 'x'], [6, 'x']],\n  },\n  \n  Dmaj7: {\n    chord: [[1, 2], [2, 2], [3, 2], [4, 0], [5, 'x'], [6, 'x']],\n  },\n  \n  D7: {\n    chord: [[1, 2], [2, 1], [3, 2], [4, 0], [5, 'x'], [6, 'x']],\n  },\n  \n  Dm: {\n    chord: [[1, 1], [2, 3], [3, 2], [4, 0], [5, 'x'], [6, 'x']],\n  },\n  \n  Dm7: {\n    chord: [[1, 1], [2, 1], [3, 2], [4, 0], [5, 'x'], [6, 'x']],\n  },\n  \n  \"D#\": {\n    position: 6,\n    chord: [[1, 1], [2, 3], [3, 3], [4, 3], [5, 1], [6, 'x']],\n    barres: [\n      { fromString: 5, toString: 1, fret: 1 },\n    ],\n  },\n  \n  \"D#m\": {\n    position: 6,\n    chord: [[1, 1], [2, 2], [3, 3], [4, 3], [5, 1], [6, 'x']],\n    barres: [\n      { fromString: 5, toString: 1, fret: 1 },\n    ],\n  },\n  \n  \"D#dim\": {\n    chord: [[1, 1], [2, 2], [3, 1], [4, 2], [5, 'x'], [6, 'x']],\n  },\n  \n  E: {\n    chord: [[1, 0], [2, 0], [3, 1], [4, 2], [5, 2], [6, 0]],\n  },\n  \n  Emaj7: {\n    chord: [[1, 0], [2, 0], [3, 1], [4, 1], [5, 2], [6, 0]],\n  },\n  \n  E7: {\n    chord: [[1, 0], [2, 0], [3, 1], [4, 0], [5, 2], [6, 0]],\n  },\n  \n  Em: {\n    chord: [[1, 0], [2, 0], [3, 0], [4, 2], [5, 2], [6, 0]],\n  },\n  \n  Em7: {\n    chord: [[1, 0], [2, 0], [3, 0], [4, 0], [5, 2], [6, 0]],\n  },\n  \n  F: {\n    chord: [[1, 1], [2, 1], [3, 2], [4, 3], [5, 3], [6, 1]],\n    barres: [\n      { fromString: 6, toString: 1, fret: 1 },\n    ],\n  },\n  \n  Fmaj7: {\n    chord: [[1, 0], [2, 1], [3, 2], [4, 3], [5, 'x'], [6, 'x']],\n  },\n  \n  F7: {\n    chord: [[1, 1], [2, 1], [3, 2], [4, 1], [5, 3], [6, 1]],\n    barres: [\n      { fromString: 6, toString: 1, fret: 1 },\n    ],\n  },\n  \n  Fm: {\n    position: 1,\n    chord: [[1, 1], [2, 1], [3, 1], [4, 3], [5, 3], [6, 1]],\n    barres: [\n      { fromString: 6, toString: 1, fret: 1 },\n    ],\n  },\n  \n  \"F#\": {\n    position: 2,\n    chord: [[1, 1], [2, 1], [3, 2], [4, 3], [5, 3], [6, 1]],\n    barres: [\n      { fromString: 6, toString: 1, fret: 1 },\n    ],\n  },\n  \n  \"F#dim\": {\n    chord: [[1, 1], [2, 2], [3, 3], [4, 1], [5, 'x'], [6, 'x']],\n  },\n  \n  \"F#m\": {\n    chord: [[1, 2], [2, 2], [3, 2], [4, 4], [5, 4], [6, 2]],\n    barres: [\n      { fromString: 6, toString: 1, fret: 2 },\n    ],\n  },\n  \n  \"F#m7\": {\n    chord: [[1, 2], [2, 0], [3, 2], [4, 2], [5, 'x'], [6, 2]],\n  },\n  \n  G: {\n    chord: [[1, 3], [2, 0], [3, 0], [4, 0], [5, 2], [6, 3]],\n  },\n  \n  Gmaj7: {\n    chord: [[1, 2], [2, 0], [3, 0], [4, 0], [5, 2], [6, 3]],\n  },\n  \n  G7: {\n    chord: [[1, 1], [2, 0], [3, 0], [4, 0], [5, 2], [6, 3]],\n  },\n  \n  Gm: {\n    position: 3,\n    chord: [[1, 1], [2, 1], [3, 1], [4, 3], [5, 3], [6, 1]],\n    barres: [\n      { fromString: 6, toString: 1, fret: 1 },\n    ],\n  },\n  \n  \"G#\": {\n    position: 4,\n    chord: [[1, 1], [2, 1], [3, 1], [4, 3], [5, 3], [6, 1]],\n    barres: [\n      { fromString: 6, toString: 1, fret: 1 },\n    ],\n  },\n  \n  \"G#dim\": {\n    chord: [[1, 4], [2, 5], [3, 3], [4, 4], [5, 3], [6, 'x']],\n  },\n  \n  \"G#m\": {\n    position: 4,\n    chord: [[1, 1], [2, 1], [3, 1], [4, 3], [5, 3], [6, 1]],\n    barres: [\n      { fromString: 6, toString: 1, fret: 1 },\n    ],\n  },\n  \n  \"G#m7\": {\n    position: 4,\n    chord: [[1, 1], [2, 1], [3, 1], [4, 1], [5, 3], [6, 1]],\n    barres: [\n      { fromString: 6, toString: 1, fret: 1 },\n    ],\n  },\n\n  A: {\n    chord: [[1, 0], [2, 2], [3, 2], [4, 2], [5, 0], [6, 'x']],\n  },\n  \n  Amaj7: {\n    chord: [[1, 0], [2, 2], [3, 1], [4, 2], [5, 0], [6, 'x']],\n  },\n  \n  A7: {\n    chord: [[1, 0], [2, 2], [3, 0], [4, 2], [5, 0], [6, 'x']],\n  },\n  \n  Am: {\n    chord: [[1, 0], [2, 1], [3, 2], [4, 2], [5, 0], [6, 'x']],\n  },\n  \n  Am7: {\n    chord: [[1, 0], [2, 1], [3, 0], [4, 2], [5, 0], [6, 'x']],\n  },\n  \n  \"A#\": {\n    position: 1,\n    chord: [[1, 1], [2, 3], [3, 3], [4, 3], [5, 1], [6, 'x']],\n    barres: [\n      { fromString: 5, toString: 1, fret: 1 },\n    ],\n  },\n  \n  \"A#m\": {\n    position: 1,\n    chord: [[1, 1], [2, 2], [3, 3], [4, 3], [5, 1], [6, 'x']],\n    barres: [\n      { fromString: 5, toString: 1, fret: 1 },\n    ],\n  },\n  \n  B: {\n    chord: [[1, 2], [2, 4], [3, 4], [4, 4], [5, 2], [6, 'x']],\n    barres: [\n      { fromString: 5, toString: 1, fret: 2 },\n    ],\n  },\n  \n  Bmaj7: {\n    chord: [[1, 2], [2, 4], [3, 3], [4, 4], [5, 2], [6, 'x']],\n    barres: [\n      { fromString: 5, toString: 1, fret: 2 },\n    ],\n  },\n  \n  B7: {\n    chord: [[1, 0], [2, 2], [3, 1], [4, 2], [5, 2], [6, 'x']],\n  },\n  \n  Bm: {\n    chord: [[1, 2], [2, 3], [3, 4], [4, 4], [5, 2], [6, 'x']],\n    barres: [\n      { fromString: 5, toString: 1, fret: 2 },\n    ],\n  },\n  \n  Bm7: {\n    chord: [[1, 0], [2, 2], [3, 0], [4, 2], [5, 2], [6, 'x']],\n  },\n};"
        },
        "deleted_files": []
    },
    {
        "commit_message": "fix degree translate for 2m/3m/6m",
        "added_files": {},
        "modified_files": {
            "src/chorder/degree.js": "/**\n * 处理级数和弦与音高和弦之间的转换。\n */\nclass DegreeTranslator {\n    constructor(useMinorShorthand = true) {\n        // 所有音高\n        this.pitches = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];\n        \n        // 自然大调的音程关系（半音数）\n        this.majorScaleIntervals = [0, 2, 4, 5, 7, 9, 11];\n        \n        // 是否使用小和弦简写（2/3/6 表示 Dm/Em/Am）\n        this.useMinorShorthand = useMinorShorthand;\n    }\n\n    /**\n     * 将级数和弦转换为音高和弦。\n     * @param {string} key - 调式，如 C\n     * @param {string} roman - 级数和弦，如 2m7\n     * @returns {string} 音高和弦，如 Dm7\n     */\n    romanToPitch(key, roman) {\n        // 从级数中提取度数（1-7）\n        const degree = parseInt(roman.charAt(0));\n        \n        // 如果degree不是合法数字，抛出异常\n        if (isNaN(degree)) {\n            throw new Error(`无效的级数: ${roman}`);\n        }\n        \n        // 获取和弦类型（去掉第一个字符后的所有内容）\n        let chordType = roman.substring(1);\n        \n        // 特殊情况处理：当开启小和弦简写时，2, 3, 6 单独出现时为小和弦\n        if (chordType === '' && this.useMinorShorthand && (degree === 2 || degree === 3 || degree === 6)) {\n            chordType = 'm';\n        } else if (chordType === 'M') {\n            // M 表示大和弦，不添加任何后缀\n            chordType = '';\n        }\n        \n        // 找到起始音高在pitches中的索引\n        const keyIndex = this.pitches.indexOf(key);\n        if (keyIndex === -1) {\n            throw new Error(`未知的调式: ${key}`);\n        }\n        \n        // 计算目标音高的索引\n        const targetIndex = (keyIndex + this.majorScaleIntervals[(degree - 1) % 7]) % 12;\n        \n        // 获取目标音高\n        const targetPitch = this.pitches[targetIndex];\n        \n        // 返回最终的和弦名称\n        return targetPitch + chordType;\n    }\n\n    /**\n     * 将音高和弦转换为级数和弦。\n     * @param {string} key - 调式，如 C\n     * @param {string} chord - 音高和弦，如 Dm7\n     * @returns {string} 级数和弦，如 2m7\n     */\n    pitchToRoman(key, chord) {\n        // 提取和弦根音和类型\n        // 假设和弦的第一个字符是根音\n        let rootPitch = chord.charAt(0);\n        let chordType = chord.substring(1);\n        \n        // 处理带有升降号的根音（如C#, Bb等）\n        if (chord.length > 1 && (chord.charAt(1) === '#' || chord.charAt(1) === 'b')) {\n            rootPitch = chord.substring(0, 2);\n            chordType = chord.substring(2);\n        }\n        \n        // 找到调式和根音在pitches中的索引\n        const keyIndex = this.pitches.indexOf(key);\n        const rootIndex = this.pitches.indexOf(rootPitch);\n        \n        if (keyIndex === -1) {\n            throw new Error(`未知的调式: ${key}`);\n        }\n        \n        if (rootIndex === -1) {\n            throw new Error(`未知的根音: ${rootPitch}`);\n        }\n        \n        // 计算根音相对于调式的半音距离\n        const semitoneDistance = (rootIndex - keyIndex + 12) % 12;\n        \n        // 在自然大调音程关系中找到对应的度数\n        let degree = -1;\n        for (let i = 0; i < this.majorScaleIntervals.length; i++) {\n            if (this.majorScaleIntervals[i] === semitoneDistance) {\n                degree = i + 1;\n                break;\n            }\n        }\n        \n        if (degree === -1) {\n            throw new Error(`无法确定和弦的度数: ${chord} 在 ${key} 调中`);\n        }\n        \n        // 根据小和弦简写规则处理和弦类型\n        if (this.useMinorShorthand) {\n            // 当启用小和弦简写时：\n            // 1. 如果是2/3/6度的小和弦(m)，转换为简写形式(无后缀)\n            // 2. 如果是2/3/6度的大和弦(无后缀)，需要明确标记为大和弦(M)\n            if (degree === 2 || degree === 3 || degree === 6) {\n                if (chordType === 'm') {\n                    chordType = '';\n                } else if (chordType === '') {\n                    chordType = 'M';\n                }\n            }\n        }\n        \n        // 返回最终的级数和弦\n        return degree + chordType;\n    }\n}\n\n/**\n * 将级数和弦转换为音高和弦。\n * @param {string} key - 调式，如 C\n * @param {string} roman - 级数和弦，如 2m7\n * @param {boolean} useMinorShorthand - 是否使用小和弦简写，默认为true\n * @returns {string} 音高和弦，如 Dm7，如果转换失败则返回原始入参roman\n */\nfunction roman_to_pitch(key, roman, useMinorShorthand = true) {\n    try {\n        const localTranslator = new DegreeTranslator(useMinorShorthand);\n        return localTranslator.romanToPitch(key, roman);\n    } catch (error) {\n        return roman;\n    }\n}\n\n/**\n * 将音高和弦转换为级数和弦。\n * @param {string} key - 调式，如 C\n * @param {string} chord - 音高和弦，如 Dm7\n * @param {boolean} useMinorShorthand - 是否使用小和弦简写，默认为true\n * @returns {string} 级数和弦，如 2m7，如果转换失败则返回原始入参chord\n */\nfunction pitch_to_roman(key, chord, useMinorShorthand = true) {\n    try {\n        const localTranslator = new DegreeTranslator(useMinorShorthand);\n        return localTranslator.pitchToRoman(key, chord);\n    } catch (error) {\n        return chord;\n    }\n}\n\nexport { roman_to_pitch, pitch_to_roman };",
            "src/chorder/degree.test.js": "import { roman_to_pitch, pitch_to_roman } from './degree.js';\n\ndescribe('roman_to_pitch', () => {\n  test('converts 1st degree to root chord in C major', () => {\n    expect(roman_to_pitch('C', '1')).toBe('C');\n  });\n\n  test('converts 2nd degree to minor chord in C major', () => {\n    expect(roman_to_pitch('C', '2')).toBe('Dm');\n  });\n\n  test('converts 3rd degree to minor chord in C major', () => {\n    expect(roman_to_pitch('C', '3')).toBe('Em');\n  });\n\n  test('converts 4th degree in C major', () => {\n    expect(roman_to_pitch('C', '4')).toBe('F');\n  });\n\n  test('converts 5th degree in C major', () => {\n    expect(roman_to_pitch('C', '5')).toBe('G');\n  });\n\n  test('converts 6th degree to minor chord in C major', () => {\n    expect(roman_to_pitch('C', '6')).toBe('Am');\n  });\n\n  test('converts 7th degree in C major', () => {\n    expect(roman_to_pitch('C', '7')).toBe('B');\n  });\n\n  test('handles chord types correctly', () => {\n    expect(roman_to_pitch('C', '3m7')).toBe('Em7');\n    expect(roman_to_pitch('C', '4maj7')).toBe('Fmaj7');\n    expect(roman_to_pitch('C', '57')).toBe('G7');\n    expect(roman_to_pitch('C', '2m7b5')).toBe('Dm7b5');\n    expect(roman_to_pitch('C', '1M')).toBe('C');\n    expect(roman_to_pitch('C', '6M')).toBe('A');\n  });\n\n  test('works with different keys', () => {\n    expect(roman_to_pitch('G', '1')).toBe('G');\n    expect(roman_to_pitch('G', '2')).toBe('Am');\n    expect(roman_to_pitch('G', '4maj7')).toBe('Cmaj7');\n    expect(roman_to_pitch('G', '5sus4')).toBe('Dsus4');\n  });\n\n  test('works with sharp keys', () => {\n    expect(roman_to_pitch('F#', '1')).toBe('F#');\n    expect(roman_to_pitch('F#', '4')).toBe('B');\n    expect(roman_to_pitch('F#', '5')).toBe('C#');\n  });\n\n  test('returns original input for invalid key', () => {\n    expect(roman_to_pitch('H', '1')).toBe('1');\n  });\n\n  test('already pitch', () => {\n    expect(roman_to_pitch('G', 'F')).toBe('F');\n  });\n  \n  test('handles useMinorShorthand=false for 2, 3, 6 degrees', () => {\n    // When useMinorShorthand is false, 2/3/6 should convert to D/E/A (not Dm/Em/Am)\n    expect(roman_to_pitch('C', '2', false)).toBe('D');\n    expect(roman_to_pitch('C', '3', false)).toBe('E');\n    expect(roman_to_pitch('C', '6', false)).toBe('A');\n    \n    // Explicit minor chords should still convert correctly\n    expect(roman_to_pitch('C', '2m', false)).toBe('Dm');\n    expect(roman_to_pitch('C', '3m', false)).toBe('Em');\n    expect(roman_to_pitch('C', '6m', false)).toBe('Am');\n    \n    // Major chords should still convert correctly\n    expect(roman_to_pitch('C', '2M', false)).toBe('D');\n    expect(roman_to_pitch('C', '3M', false)).toBe('E');\n    expect(roman_to_pitch('C', '6M', false)).toBe('A');\n  });\n});\n\ndescribe('pitch_to_roman', () => {\n  test('converts root chord to 1st degree in C major', () => {\n    expect(pitch_to_roman('C', 'C')).toBe('1');\n  });\n\n  test('converts minor chord to 2nd degree in C major', () => {\n    expect(pitch_to_roman('C', 'Dm')).toBe('2');\n  });\n\n  test('converts minor chord to 3rd degree in C major', () => {\n    expect(pitch_to_roman('C', 'Em')).toBe('3');\n  });\n\n  test('converts 4th degree chord in C major', () => {\n    expect(pitch_to_roman('C', 'F')).toBe('4');\n  });\n\n  test('converts 5th degree chord in C major', () => {\n    expect(pitch_to_roman('C', 'G')).toBe('5');\n  });\n\n  test('converts minor chord to 6th degree in C major', () => {\n    expect(pitch_to_roman('C', 'Am')).toBe('6');\n  });\n\n  test('converts 7th degree chord in C major', () => {\n    expect(pitch_to_roman('C', 'B')).toBe('7');\n  });\n\n  test('handles chord types correctly', () => {\n    expect(pitch_to_roman('C', 'Em7')).toBe('3m7');\n    expect(pitch_to_roman('C', 'Fmaj7')).toBe('4maj7');\n    expect(pitch_to_roman('C', 'G7')).toBe('57');\n    expect(pitch_to_roman('C', 'Dm7b5')).toBe('2m7b5');\n  });\n\n  test('works with different keys', () => {\n    expect(pitch_to_roman('G', 'G')).toBe('1');\n    expect(pitch_to_roman('G', 'Am')).toBe('2');\n    expect(pitch_to_roman('G', 'Cmaj7')).toBe('4maj7');\n    expect(pitch_to_roman('G', 'Dsus4')).toBe('5sus4');\n  });\n\n  test('works with sharp keys', () => {\n    expect(pitch_to_roman('F#', 'F#')).toBe('1');\n    expect(pitch_to_roman('F#', 'B')).toBe('4');\n    expect(pitch_to_roman('F#', 'C#')).toBe('5');\n  });\n\n  test('returns original input for invalid key', () => {\n    expect(pitch_to_roman('H', 'C')).toBe('C');\n  });\n\n  test('returns original input for invalid root pitch', () => {\n    expect(pitch_to_roman('C', 'H')).toBe('H');\n  });\n\n  test('returns original input for non-diatonic chord', () => {\n    expect(pitch_to_roman('C', 'C#')).toBe('C#');\n  });\n  \n  test('handles 2/3/6 major chords with useMinorShorthand=true', () => {\n    // When useMinorShorthand is true, major 2/3/6 chords should convert to 2M/3M/6M\n    expect(pitch_to_roman('C', 'D')).toBe('2M');\n    expect(pitch_to_roman('C', 'E')).toBe('3M');\n    expect(pitch_to_roman('C', 'A')).toBe('6M');\n  });\n  \n  test('handles useMinorShorthand=false for all chords', () => {\n    // Without minor shorthand, minor chords should keep the 'm'\n    expect(pitch_to_roman('C', 'Dm', false)).toBe('2m');\n    expect(pitch_to_roman('C', 'Em', false)).toBe('3m');\n    expect(pitch_to_roman('C', 'Am', false)).toBe('6m');\n    \n    // Major chords should convert without adding 'M'\n    expect(pitch_to_roman('C', 'D', false)).toBe('2');\n    expect(pitch_to_roman('C', 'E', false)).toBe('3');\n    expect(pitch_to_roman('C', 'A', false)).toBe('6');\n  });\n});\n\ndescribe('bidirectional conversion works with useMinorShorthand', () => {\n  test('works with useMinorShorthand=true', () => {\n    const chords = ['C', 'Dm', 'Em', 'F', 'G', 'Am', 'B', 'D', 'E', 'A'];\n    const key = 'C';\n\n    chords.forEach(chord => {\n      const roman = pitch_to_roman(key, chord, true);\n      const backToChord = roman_to_pitch(key, roman, true);\n      expect(backToChord).toBe(chord);\n    });\n  });\n\n  test('works with useMinorShorthand=false', () => {\n    const chords = ['C', 'Dm', 'Em', 'F', 'G', 'Am', 'B', 'D', 'E', 'A'];\n    const key = 'C';\n\n    chords.forEach(chord => {\n      const roman = pitch_to_roman(key, chord, false);\n      const backToChord = roman_to_pitch(key, roman, false);\n      expect(backToChord).toBe(chord);\n    });\n  });\n});"
        },
        "deleted_files": []
    },
    {
        "commit_message": "degree useMinor 7",
        "added_files": {},
        "modified_files": {
            "src/chorder/degree.js": "/**\n * 处理级数和弦与音高和弦之间的转换。\n */\nclass DegreeTranslator {\n    constructor(useMinorShorthand = true) {\n        // 所有音高\n        this.pitches = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];\n        \n        // 自然大调的音程关系（半音数）\n        this.majorScaleIntervals = [0, 2, 4, 5, 7, 9, 11];\n        \n        // 是否使用小和弦简写（2/3/6 表示 Dm/Em/Am）\n        this.useMinorShorthand = useMinorShorthand;\n    }\n\n    /**\n     * 将级数和弦转换为音高和弦。\n     * @param {string} key - 调式，如 C\n     * @param {string} roman - 级数和弦，如 2m7\n     * @returns {string} 音高和弦，如 Dm7\n     */\n    romanToPitch(key, roman) {\n        // 从级数中提取度数（1-7）\n        const degree = parseInt(roman.charAt(0));\n        \n        // 如果degree不是合法数字，抛出异常\n        if (isNaN(degree)) {\n            throw new Error(`无效的级数: ${roman}`);\n        }\n        \n        // 获取和弦类型（去掉第一个字符后的所有内容）\n        let chordType = roman.substring(1);\n        \n        // 特殊情况处理：\n        // 当开启小和弦简写时，2, 3, 6 单独出现时为小和弦\n        // 当开启小和弦简写时，7 单独出现时为减和弦\n        if (chordType === '' && this.useMinorShorthand) {\n            if (degree === 2 || degree === 3 || degree === 6) {\n                chordType = 'm';\n            } else if (degree === 7) {\n                chordType = 'dim';\n            }\n        } else if (chordType === 'M') {\n            // M 表示大和弦，不添加任何后缀\n            chordType = '';\n        }\n        \n        // 找到起始音高在pitches中的索引\n        const keyIndex = this.pitches.indexOf(key);\n        if (keyIndex === -1) {\n            throw new Error(`未知的调式: ${key}`);\n        }\n        \n        // 计算目标音高的索引\n        const targetIndex = (keyIndex + this.majorScaleIntervals[(degree - 1) % 7]) % 12;\n        \n        // 获取目标音高\n        const targetPitch = this.pitches[targetIndex];\n        \n        // 返回最终的和弦名称\n        return targetPitch + chordType;\n    }\n\n    /**\n     * 将音高和弦转换为级数和弦。\n     * @param {string} key - 调式，如 C\n     * @param {string} chord - 音高和弦，如 Dm7\n     * @returns {string} 级数和弦，如 2m7\n     */\n    pitchToRoman(key, chord) {\n        // 提取和弦根音和类型\n        // 假设和弦的第一个字符是根音\n        let rootPitch = chord.charAt(0);\n        let chordType = chord.substring(1);\n        \n        // 处理带有升降号的根音（如C#, Bb等）\n        if (chord.length > 1 && (chord.charAt(1) === '#' || chord.charAt(1) === 'b')) {\n            rootPitch = chord.substring(0, 2);\n            chordType = chord.substring(2);\n        }\n        \n        // 找到调式和根音在pitches中的索引\n        const keyIndex = this.pitches.indexOf(key);\n        const rootIndex = this.pitches.indexOf(rootPitch);\n        \n        if (keyIndex === -1) {\n            throw new Error(`未知的调式: ${key}`);\n        }\n        \n        if (rootIndex === -1) {\n            throw new Error(`未知的根音: ${rootPitch}`);\n        }\n        \n        // 计算根音相对于调式的半音距离\n        const semitoneDistance = (rootIndex - keyIndex + 12) % 12;\n        \n        // 在自然大调音程关系中找到对应的度数\n        let degree = -1;\n        for (let i = 0; i < this.majorScaleIntervals.length; i++) {\n            if (this.majorScaleIntervals[i] === semitoneDistance) {\n                degree = i + 1;\n                break;\n            }\n        }\n        \n        if (degree === -1) {\n            throw new Error(`无法确定和弦的度数: ${chord} 在 ${key} 调中`);\n        }\n        \n        // 根据小和弦简写规则处理和弦类型\n        if (this.useMinorShorthand) {\n            // 当启用小和弦简写时：\n            // 1. 如果是2/3/6度的小和弦(m)，转换为简写形式(无后缀)\n            // 2. 如果是2/3/6度的大和弦(无后缀)，需要明确标记为大和弦(M)\n            // 3. 如果是7度的减和弦(dim)，转换为简写形式(无后缀)\n            if (degree === 2 || degree === 3 || degree === 6) {\n                if (chordType === 'm') {\n                    chordType = '';\n                } else if (chordType === '') {\n                    chordType = 'M';\n                }\n            } else if (degree === 7) {\n                if (chordType === 'dim') {\n                    chordType = '';\n                } else if (chordType === '') {\n                    chordType = 'M';\n                }\n            }\n        }\n        \n        // 返回最终的级数和弦\n        return degree + chordType;\n    }\n}\n\n/**\n * 将级数和弦转换为音高和弦。\n * @param {string} key - 调式，如 C\n * @param {string} roman - 级数和弦，如 2m7\n * @param {boolean} useMinorShorthand - 是否使用小和弦简写，默认为true\n * @returns {string} 音高和弦，如 Dm7，如果转换失败则返回原始入参roman\n */\nfunction roman_to_pitch(key, roman, useMinorShorthand = true) {\n    try {\n        const localTranslator = new DegreeTranslator(useMinorShorthand);\n        return localTranslator.romanToPitch(key, roman);\n    } catch (error) {\n        return roman;\n    }\n}\n\n/**\n * 将音高和弦转换为级数和弦。\n * @param {string} key - 调式，如 C\n * @param {string} chord - 音高和弦，如 Dm7\n * @param {boolean} useMinorShorthand - 是否使用小和弦简写，默认为true\n * @returns {string} 级数和弦，如 2m7，如果转换失败则返回原始入参chord\n */\nfunction pitch_to_roman(key, chord, useMinorShorthand = true) {\n    try {\n        const localTranslator = new DegreeTranslator(useMinorShorthand);\n        return localTranslator.pitchToRoman(key, chord);\n    } catch (error) {\n        return chord;\n    }\n}\n\nexport { roman_to_pitch, pitch_to_roman };",
            "src/chorder/degree.test.js": "import { roman_to_pitch, pitch_to_roman } from './degree.js';\n\ndescribe('roman_to_pitch', () => {\n  test('converts 1st degree to root chord in C major', () => {\n    expect(roman_to_pitch('C', '1')).toBe('C');\n  });\n\n  test('converts 2nd degree to minor chord in C major', () => {\n    expect(roman_to_pitch('C', '2')).toBe('Dm');\n  });\n\n  test('converts 3rd degree to minor chord in C major', () => {\n    expect(roman_to_pitch('C', '3')).toBe('Em');\n  });\n\n  test('converts 4th degree in C major', () => {\n    expect(roman_to_pitch('C', '4')).toBe('F');\n  });\n\n  test('converts 5th degree in C major', () => {\n    expect(roman_to_pitch('C', '5')).toBe('G');\n  });\n\n  test('converts 6th degree to minor chord in C major', () => {\n    expect(roman_to_pitch('C', '6')).toBe('Am');\n  });\n\n  test('converts 7th degree to diminished chord in C major with useMinorShorthand=true', () => {\n    expect(roman_to_pitch('C', '7')).toBe('Bdim');\n  });\n\n  test('converts 7th degree in C major with useMinorShorthand=false', () => {\n    expect(roman_to_pitch('C', '7', false)).toBe('B');\n  });\n\n  test('handles chord types correctly', () => {\n    expect(roman_to_pitch('C', '3m7')).toBe('Em7');\n    expect(roman_to_pitch('C', '4maj7')).toBe('Fmaj7');\n    expect(roman_to_pitch('C', '57')).toBe('G7');\n    expect(roman_to_pitch('C', '2m7b5')).toBe('Dm7b5');\n    expect(roman_to_pitch('C', '1M')).toBe('C');\n    expect(roman_to_pitch('C', '6M')).toBe('A');\n    expect(roman_to_pitch('C', '7M')).toBe('B');\n    expect(roman_to_pitch('C', '7dim')).toBe('Bdim');\n  });\n\n  test('works with different keys', () => {\n    expect(roman_to_pitch('G', '1')).toBe('G');\n    expect(roman_to_pitch('G', '2')).toBe('Am');\n    expect(roman_to_pitch('G', '4maj7')).toBe('Cmaj7');\n    expect(roman_to_pitch('G', '5sus4')).toBe('Dsus4');\n  });\n\n  test('works with sharp keys', () => {\n    expect(roman_to_pitch('F#', '1')).toBe('F#');\n    expect(roman_to_pitch('F#', '4')).toBe('B');\n    expect(roman_to_pitch('F#', '5')).toBe('C#');\n  });\n\n  test('returns original input for invalid key', () => {\n    expect(roman_to_pitch('H', '1')).toBe('1');\n  });\n\n  test('already pitch', () => {\n    expect(roman_to_pitch('G', 'F')).toBe('F');\n  });\n  \n  test('handles useMinorShorthand=false for 2, 3, 6 degrees', () => {\n    // When useMinorShorthand is false, 2/3/6 should convert to D/E/A (not Dm/Em/Am)\n    expect(roman_to_pitch('C', '2', false)).toBe('D');\n    expect(roman_to_pitch('C', '3', false)).toBe('E');\n    expect(roman_to_pitch('C', '6', false)).toBe('A');\n    \n    // Explicit minor chords should still convert correctly\n    expect(roman_to_pitch('C', '2m', false)).toBe('Dm');\n    expect(roman_to_pitch('C', '3m', false)).toBe('Em');\n    expect(roman_to_pitch('C', '6m', false)).toBe('Am');\n    \n    // Major chords should still convert correctly\n    expect(roman_to_pitch('C', '2M', false)).toBe('D');\n    expect(roman_to_pitch('C', '3M', false)).toBe('E');\n    expect(roman_to_pitch('C', '6M', false)).toBe('A');\n  });\n});\n\ndescribe('pitch_to_roman', () => {\n  test('converts root chord to 1st degree in C major', () => {\n    expect(pitch_to_roman('C', 'C')).toBe('1');\n  });\n\n  test('converts minor chord to 2nd degree in C major', () => {\n    expect(pitch_to_roman('C', 'Dm')).toBe('2');\n  });\n\n  test('converts minor chord to 3rd degree in C major', () => {\n    expect(pitch_to_roman('C', 'Em')).toBe('3');\n  });\n\n  test('converts 4th degree chord in C major', () => {\n    expect(pitch_to_roman('C', 'F')).toBe('4');\n  });\n\n  test('converts 5th degree chord in C major', () => {\n    expect(pitch_to_roman('C', 'G')).toBe('5');\n  });\n\n  test('converts minor chord to 6th degree in C major', () => {\n    expect(pitch_to_roman('C', 'Am')).toBe('6');\n  });\n\n  test('converts 7th degree diminished chord to 7 in C major with useMinorShorthand=true', () => {\n    expect(pitch_to_roman('C', 'Bdim')).toBe('7');\n  });\n\n  test('converts 7th degree chord in C major with useMinorShorthand=false', () => {\n    expect(pitch_to_roman('C', 'Bdim', false)).toBe('7dim');\n  });\n\n  test('handles chord types correctly', () => {\n    expect(pitch_to_roman('C', 'Em7')).toBe('3m7');\n    expect(pitch_to_roman('C', 'Fmaj7')).toBe('4maj7');\n    expect(pitch_to_roman('C', 'G7')).toBe('57');\n    expect(pitch_to_roman('C', 'Dm7b5')).toBe('2m7b5');\n  });\n\n  test('works with different keys', () => {\n    expect(pitch_to_roman('G', 'G')).toBe('1');\n    expect(pitch_to_roman('G', 'Am')).toBe('2');\n    expect(pitch_to_roman('G', 'Cmaj7')).toBe('4maj7');\n    expect(pitch_to_roman('G', 'Dsus4')).toBe('5sus4');\n    expect(pitch_to_roman('G', 'F#dim')).toBe('7');\n  });\n\n  test('works with sharp keys', () => {\n    expect(pitch_to_roman('F#', 'F#')).toBe('1');\n    expect(pitch_to_roman('F#', 'B')).toBe('4');\n    expect(pitch_to_roman('F#', 'C#')).toBe('5');\n  });\n\n  test('returns original input for invalid key', () => {\n    expect(pitch_to_roman('H', 'C')).toBe('C');\n  });\n\n  test('returns original input for invalid root pitch', () => {\n    expect(pitch_to_roman('C', 'H')).toBe('H');\n  });\n\n  test('returns original input for non-diatonic chord', () => {\n    expect(pitch_to_roman('C', 'C#')).toBe('C#');\n  });\n  \n  test('handles 2/3/6 major chords with useMinorShorthand=true', () => {\n    // When useMinorShorthand is true, major 2/3/6 chords should convert to 2M/3M/6M\n    expect(pitch_to_roman('C', 'D')).toBe('2M');\n    expect(pitch_to_roman('C', 'E')).toBe('3M');\n    expect(pitch_to_roman('C', 'A')).toBe('6M');\n  });\n  \n  test('handles useMinorShorthand=false for all chords', () => {\n    // Without minor shorthand, minor chords should keep the 'm'\n    expect(pitch_to_roman('C', 'Dm', false)).toBe('2m');\n    expect(pitch_to_roman('C', 'Em', false)).toBe('3m');\n    expect(pitch_to_roman('C', 'Am', false)).toBe('6m');\n    \n    // Major chords should convert without adding 'M'\n    expect(pitch_to_roman('C', 'D', false)).toBe('2');\n    expect(pitch_to_roman('C', 'E', false)).toBe('3');\n    expect(pitch_to_roman('C', 'A', false)).toBe('6');\n    \n    // Diminished chords should keep 'dim'\n    expect(pitch_to_roman('C', 'Bdim', false)).toBe('7dim');\n  });\n});\n\ndescribe('bidirectional conversion works with useMinorShorthand', () => {\n  test('works with useMinorShorthand=true', () => {\n    const chords = ['C', 'Dm', 'Em', 'F', 'G', 'Am', 'Bdim', 'D', 'E', 'A', 'B'];\n    const key = 'C';\n\n    chords.forEach(chord => {\n      const roman = pitch_to_roman(key, chord, true);\n      const backToChord = roman_to_pitch(key, roman, true);\n      expect(backToChord).toBe(chord);\n    });\n  });\n\n  test('works with useMinorShorthand=false', () => {\n    const chords = ['C', 'Dm', 'Em', 'F', 'G', 'Am', 'B', 'D', 'E', 'A', 'Bdim'];\n    const key = 'C';\n\n    chords.forEach(chord => {\n      const roman = pitch_to_roman(key, chord, false);\n      const backToChord = roman_to_pitch(key, roman, false);\n      expect(backToChord).toBe(chord);\n    });\n  });\n});"
        },
        "deleted_files": []
    },
    {
        "commit_message": "review degree testcase",
        "added_files": {},
        "modified_files": {
            "src/chorder/degree.test.js": "import { roman_to_pitch, pitch_to_roman } from './degree.js';\n\ndescribe('roman_to_pitch', () => {\n  test('C major scale, with shorthand', () => {\n    expect(roman_to_pitch('C', '1')).toBe('C');\n    expect(roman_to_pitch('C', '2')).toBe('Dm');\n    expect(roman_to_pitch('C', '3')).toBe('Em');\n    expect(roman_to_pitch('C', '4')).toBe('F');\n    expect(roman_to_pitch('C', '5')).toBe('G');\n    expect(roman_to_pitch('C', '6')).toBe('Am');\n    expect(roman_to_pitch('C', '7')).toBe('Bdim');\n  });\n\n  test('C major scale, with no shorthand', () => {\n    expect(roman_to_pitch('C', '1')).toBe('C');\n    expect(roman_to_pitch('C', '2m')).toBe('Dm');\n    expect(roman_to_pitch('C', '3m')).toBe('Em');\n    expect(roman_to_pitch('C', '4')).toBe('F');\n    expect(roman_to_pitch('C', '5')).toBe('G');\n    expect(roman_to_pitch('C', '6m')).toBe('Am');\n    expect(roman_to_pitch('C', '7dim')).toBe('Bdim');\n  });\n\n  test('handles chord types correctly', () => {\n    expect(roman_to_pitch('C', '3m7')).toBe('Em7');\n    expect(roman_to_pitch('C', '4maj7')).toBe('Fmaj7');\n    expect(roman_to_pitch('C', '57')).toBe('G7');\n    expect(roman_to_pitch('C', '2m7b5')).toBe('Dm7b5');\n    expect(roman_to_pitch('C', '1M')).toBe('C');\n    expect(roman_to_pitch('C', '6M')).toBe('A');\n    expect(roman_to_pitch('C', '7M')).toBe('B');\n    expect(roman_to_pitch('C', '7dim')).toBe('Bdim');\n  });\n\n  test('handles shorthand for 2, 3, 6, 7 degrees', () => {\n    // When useMinorShorthand is true, 2/3/6/7 should convert to Dm/Em/Am/Bdim\n    expect(roman_to_pitch('C', '2', true)).toBe('Dm');\n    expect(roman_to_pitch('C', '3', true)).toBe('Em');\n    expect(roman_to_pitch('C', '6', true)).toBe('Am');\n    expect(roman_to_pitch('C', '7', true)).toBe('Bdim');\n\n    // Major chords should still convert correctly\n    expect(roman_to_pitch('C', '2M', true)).toBe('D');\n    expect(roman_to_pitch('C', '3M', true)).toBe('E');\n    expect(roman_to_pitch('C', '6M', true)).toBe('A');\n    expect(roman_to_pitch('C', '7M', true)).toBe('B');\n\n    // When useMinorShorthand is false, 2/3/6/7 should convert to D/E/A/B (not Dm/Em/Am/Bdim)\n    expect(roman_to_pitch('C', '2', false)).toBe('D');\n    expect(roman_to_pitch('C', '3', false)).toBe('E');\n    expect(roman_to_pitch('C', '6', false)).toBe('A');\n    expect(roman_to_pitch('C', '7', false)).toBe('B');\n    \n    // Explicit minor chords should still convert correctly\n    expect(roman_to_pitch('C', '2m', false)).toBe('Dm');\n    expect(roman_to_pitch('C', '3m', false)).toBe('Em');\n    expect(roman_to_pitch('C', '6m', false)).toBe('Am');\n    expect(roman_to_pitch('C', '7dim', false)).toBe('Bdim');\n  });\n\n  test('works with different keys', () => {\n    expect(roman_to_pitch('G', '1')).toBe('G');\n    expect(roman_to_pitch('G', '2')).toBe('Am');\n    expect(roman_to_pitch('G', '4maj7')).toBe('Cmaj7');\n    expect(roman_to_pitch('G', '5sus4')).toBe('Dsus4');\n  });\n\n  test('works with sharp keys', () => {\n    expect(roman_to_pitch('F#', '1')).toBe('F#');\n    expect(roman_to_pitch('F#', '4')).toBe('B');\n    expect(roman_to_pitch('F#', '5')).toBe('C#');\n  });\n\n  test('returns original input for invalid key', () => {\n    expect(roman_to_pitch('H', '1')).toBe('1');\n  });\n\n  test('already pitch', () => {\n    expect(roman_to_pitch('G', 'F')).toBe('F');\n  });\n});\n\ndescribe('pitch_to_roman', () => {\n  test('C major scale, with shorthand', () => {\n    expect(pitch_to_roman('C', 'C')).toBe('1');\n    expect(pitch_to_roman('C', 'Dm')).toBe('2');\n    expect(pitch_to_roman('C', 'Em')).toBe('3');\n    expect(pitch_to_roman('C', 'F')).toBe('4');\n    expect(pitch_to_roman('C', 'G')).toBe('5');\n    expect(pitch_to_roman('C', 'Am')).toBe('6');\n    expect(pitch_to_roman('C', 'Bdim')).toBe('7');\n  });\n  \n  test('C major scale, with no shorthand', () => {\n    expect(pitch_to_roman('C', 'C', false)).toBe('1');\n    expect(pitch_to_roman('C', 'Dm', false)).toBe('2m');\n    expect(pitch_to_roman('C', 'Em', false)).toBe('3m');\n    expect(pitch_to_roman('C', 'F', false)).toBe('4');\n    expect(pitch_to_roman('C', 'G', false)).toBe('5');\n    expect(pitch_to_roman('C', 'A', false)).toBe('6');\n    expect(pitch_to_roman('C', 'B', false)).toBe('7');\n  });\n\n  test('handles chord types correctly', () => {\n    expect(pitch_to_roman('C', 'Em7')).toBe('3m7');\n    expect(pitch_to_roman('C', 'Fmaj7')).toBe('4maj7');\n    expect(pitch_to_roman('C', 'G7')).toBe('57');\n    expect(pitch_to_roman('C', 'Dm7b5')).toBe('2m7b5');\n  });\n\n  test('handles shorthand for 2, 3, 6, 7 degrees', () => {\n    // When useMinorShorthand is true, Dm/Em/Am/Bdim should convert to 2/3/6/7\n    expect(pitch_to_roman('C', 'Dm', true)).toBe('2');\n    expect(pitch_to_roman('C', 'Em', true)).toBe('3');\n    expect(pitch_to_roman('C', 'Am', true)).toBe('6');\n    expect(pitch_to_roman('C', 'Bdim', true)).toBe('7');\n\n    // Major chords should convert to 2M/3M/6M/7M\n    expect(pitch_to_roman('C', 'D', true)).toBe('2M');\n    expect(pitch_to_roman('C', 'E', true)).toBe('3M');\n    expect(pitch_to_roman('C', 'A', true)).toBe('6M');\n    expect(pitch_to_roman('C', 'B', true)).toBe('7M');\n\n    // When useMinorShorthand is false, D/E/A/B should convert to 2/3/6/7\n    expect(pitch_to_roman('C', 'D', false)).toBe('2');\n    expect(pitch_to_roman('C', 'E', false)).toBe('3');\n    expect(pitch_to_roman('C', 'A', false)).toBe('6');\n    expect(pitch_to_roman('C', 'B', false)).toBe('7');\n\n    // Minor chords should convert to 2m/3m/6m/7dim\n    expect(pitch_to_roman('C', 'Dm', false)).toBe('2m');\n    expect(pitch_to_roman('C', 'Em', false)).toBe('3m');\n    expect(pitch_to_roman('C', 'Am', false)).toBe('6m');\n    expect(pitch_to_roman('C', 'Bdim', false)).toBe('7dim');\n  });\n\n  test('works with different keys', () => {\n    expect(pitch_to_roman('G', 'G')).toBe('1');\n    expect(pitch_to_roman('G', 'Am')).toBe('2');\n    expect(pitch_to_roman('G', 'Cmaj7')).toBe('4maj7');\n    expect(pitch_to_roman('G', 'Dsus4')).toBe('5sus4');\n    expect(pitch_to_roman('G', 'F#dim')).toBe('7');\n  });\n\n  test('works with sharp keys', () => {\n    expect(pitch_to_roman('F#', 'F#')).toBe('1');\n    expect(pitch_to_roman('F#', 'B')).toBe('4');\n    expect(pitch_to_roman('F#', 'C#')).toBe('5');\n  });\n\n  test('returns original input for invalid key', () => {\n    expect(pitch_to_roman('H', 'C')).toBe('C');\n  });\n\n  test('returns original input for invalid root pitch', () => {\n    expect(pitch_to_roman('C', 'H')).toBe('H');\n  });\n\n  test('returns original input for non-diatonic chord', () => {\n    expect(pitch_to_roman('C', 'C#')).toBe('C#');\n  });\n});\n\ndescribe('bidirectional conversion works with useMinorShorthand', () => {\n  test('pitch to roman to pitch, with useMinorShorthand=true', () => {\n    const chords = ['C', 'Dm', 'Em', 'F', 'G', 'Am', 'Bdim', 'D', 'E', 'A', 'B'];\n    const key = 'C';\n\n    chords.forEach(chord => {\n      const roman = pitch_to_roman(key, chord, true);\n      const backToChord = roman_to_pitch(key, roman, true);\n      expect(backToChord).toBe(chord);\n    });\n  });\n\n  test('pitch to roman to pitch, with useMinorShorthand=false', () => {\n    const chords = ['C', 'Dm', 'Em', 'F', 'G', 'Am', 'B', 'D', 'E', 'A', 'Bdim'];\n    const key = 'C';\n\n    chords.forEach(chord => {\n      const roman = pitch_to_roman(key, chord, false);\n      const backToChord = roman_to_pitch(key, roman, false);\n      expect(backToChord).toBe(chord);\n    });\n  });\n\n  test('roman to pitch to roman, with useMinorShorthand=true', () => {\n    const chords = ['1', '2', '3', '4', '5', '6', '7', '2M', '3M', '6M', '7M'];\n    const key = 'C';\n\n    chords.forEach(chord => {\n      const roman = roman_to_pitch(key, chord, true);\n      const backToChord = pitch_to_roman(key, roman, true);\n      expect(backToChord).toBe(chord);\n    });\n  });\n\n  test('roman to pitch to roman, with useMinorShorthand=false', () => {\n    const chords = ['1', '2', '3', '4', '5', '6', '7', '2m', '3m', '6m', '7dim'];\n    const key = 'C';\n\n    chords.forEach(chord => {\n      const roman = roman_to_pitch(key, chord, false);\n      const backToChord = pitch_to_roman(key, roman, false);\n      expect(backToChord).toBe(chord);\n    });\n  });\n});"
        },
        "deleted_files": []
    }
]
