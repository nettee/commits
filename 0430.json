[
    {
        "commit_message": "refactor type definition",
        "added_files": {
            ".cursor/rules/ask-to-agent.mdc": "---\ndescription: \nglobs: \nalwaysApply: false\n---\n把以上方案写成一份修改代码的 prompt，我要交给 claude 3.7 写代码。要求直接输入 prompt 内容，不包含多余的话，可以直接复制。"
        },
        "modified_files": {
            "src/chorder/chordbox.ts": "import {SVG, Svg, Text, Line, Rect, Circle, StrokeData} from '@svgdotjs/svg.js';\nimport { ChordDefinition, Barre } from '@/types';\n\n/**\n * Font options for text rendering\n */\ninterface FontOptions {\n    family: string;\n    size: number;\n    style: string;\n    weight: string;\n}\n\n/**\n * Text drawing options\n */\ninterface TextOptions {\n    stroke: string | StrokeData;\n    fill: string;\n}\n\n/**\n * Rectangle drawing options\n */\ninterface RectOptions {\n    fill?: string;\n    stroke?: StrokeData;\n    radius?: number;\n}\n\n/**\n * Circle drawing options\n */\ninterface CircleOptions {\n    fill?: string;\n    stroke?: StrokeData;\n}\n\n/**\n * Canvas metrics\n */\ninterface ChordMetrics {\n    circleRadius: number;\n    barreRadius: number;\n    fontSize: number;\n    barShiftX: number;\n    bridgeStrokeWidth: number;\n}\n\n/**\n * ChordBox 组件类型定义\n */\n\n/**\n * ChordBox 构造函数参数\n */\nexport interface ChordBoxParams {\n  /** 弦数 */\n  numStrings?: number;\n  /** 品格数量 */\n  numFrets?: number;\n  /** X坐标偏移 */\n  x?: number;\n  /** Y坐标偏移 */\n  y?: number;\n  /** 宽度 */\n  width?: number;\n  /** 高度 */\n  height?: number;\n  /** 线条宽度 */\n  strokeWidth?: number;\n  /** 是否显示调音信息 */\n  showTuning?: boolean;\n  /** 默认颜色 */\n  defaultColor?: string;\n  /** 背景颜色 */\n  bgColor?: string;\n  /** 标签颜色 */\n  labelColor?: string;\n  /** 弦色 */\n  stringColor?: string;\n  /** 品格颜色 */\n  fretColor?: string;\n  /** 琴桥颜色 */\n  bridgeColor?: string;\n  /** 线条颜色 */\n  strokeColor?: string;\n  /** 文本颜色 */\n  textColor?: string;\n  /** 弦线宽度 */\n  stringWidth?: number;\n  /** 品格线宽度 */\n  fretWidth?: number;\n  /** 字体家族 */\n  fontFamily?: string;\n  /** 字体大小 */\n  fontSize?: number;\n  /** 字体样式 */\n  fontStyle?: string;\n  /** 字体粗细 */\n  fontWeight?: string;\n  /** 标签粗细 */\n  labelWeight?: string;\n  /** 索引签名，允许访问任意键 */\n  [key: string]: any;\n}\n\n/**\n * 和弦图光带参数\n */\nexport interface LightUpParams {\n  /** 弦号 */\n  string: number;\n  /** 品格 */\n  fret: number | 'x';\n  /** 可选标签 */\n  label?: string;\n}\n\n/**\n * 文本绘制属性\n */\nexport interface TextAttrs {\n  /** 字体家族 */\n  family?: string;\n  /** 字体大小 */\n  size?: number;\n  /** 字体样式 */\n  style?: string;\n  /** 字体粗细 */\n  weight?: string;\n}\n\n/**\n * CanvasDrawer implements low-level canvas drawing operations\n * It encapsulates the SVG.js operations to provide a simplified interface\n */\nclass CanvasDrawer {\n    canvas: Svg;\n\n    /**\n     * Creates a new CanvasDrawer instance\n     * @param container - A DOM element where the diagram will be rendered\n     * @param width - Original width of the canvas\n     * @param height - Original height of the canvas\n     */\n    constructor(container: HTMLElement, width: number, height: number) {\n        this.canvas = this.createCanvas(container, width, height);\n    }\n\n    /**\n     * Creates the SVG canvas element and configures its initial properties\n     * @param container - A DOM element where the diagram will be rendered\n     * @param width - Original width of the canvas\n     * @param height - Original height of the canvas\n     * @returns The SVG canvas element\n     */\n    createCanvas(container: HTMLElement, width: number, height: number): Svg {\n        // Create canvas and add it to the DOM\n        const canvas = SVG()\n            .addTo(container)\n            .size(width, height)\n            .viewbox(0, 0, width, height)\n            .attr('preserveAspectRatio', 'xMidYMid meet');\n\n        // Scale according to parent container size, and center\n        const parentHeight = container.clientHeight;\n        const parentWidth = container.clientWidth;\n        const scaleFactor = Math.min(parentHeight / height, parentWidth / width);\n\n        canvas.scale(scaleFactor);\n        canvas.translate((parentWidth - width) / 2, (parentHeight - height) / 2);\n\n        return canvas;\n    }\n\n    /**\n     * Draws text on the canvas\n     * @param x - X coordinate\n     * @param y - Y coordinate\n     * @param msg - Text message to display\n     * @param font - Text font options (must include family, size, style, weight)\n     * @param options - Required styling options\n     * @returns The text element object\n     */\n    drawText(x: number, y: number, msg: string, font: FontOptions, options: TextOptions): Text {\n        const text = this.canvas\n            .text(`${msg}`)\n            .font(font);\n            \n        // Handle different types of stroke parameter\n        if (typeof options.stroke === 'string') {\n            text.stroke(options.stroke as string);\n        } else {\n            text.stroke(options.stroke as StrokeData);\n        }\n        \n        text.fill(options.fill);\n\n        return text.move(x - text.length() / 2, y);\n    }\n\n    /**\n     * Draws a line on the canvas\n     * @param x - Starting X coordinate\n     * @param y - Starting Y coordinate\n     * @param newX - Ending X coordinate\n     * @param newY - Ending Y coordinate\n     * @returns The line element object\n     */\n    drawLine(x: number, y: number, newX: number, newY: number): Line {\n        return this.canvas\n            .line(0, 0, newX - x, newY - y)\n            .move(x, y);\n    }\n\n    /**\n     * Draws a rectangle on the canvas\n     * @param x - X coordinate\n     * @param y - Y coordinate\n     * @param width - Rectangle width\n     * @param height - Rectangle height\n     * @param options - Optional styling options\n     * @returns The rectangle element object\n     */\n    drawRect(x: number, y: number, width: number, height: number, options: RectOptions = {}): Rect {\n        const rect = this.canvas\n            .rect(width, height)\n            .move(x, y);\n        if (options.fill) {\n            rect.fill(options.fill);\n        }\n        if (options.stroke) {\n            rect.stroke(options.stroke);\n        }\n        if (options.radius) {\n            rect.radius(options.radius);\n        }\n        return rect;\n    }\n\n    /**\n     * Draws a circle on the canvas\n     * @param x - X coordinate of the center\n     * @param y - Y coordinate of the center\n     * @param radius - Circle radius\n     * @param options - Optional styling options\n     * @returns The circle element object\n     */\n    drawCircle(x: number, y: number, radius: number, options: CircleOptions = {}): Circle {\n        const circle = this.canvas\n            .circle()\n            .move(x, y)\n            .radius(radius);\n        if (options.fill) {\n            circle.fill(options.fill);\n        }\n        if (options.stroke) {\n            circle.stroke(options.stroke);\n        }\n        return circle;\n    }\n}\n\n/**\n * ChordBox implements the rendering logic for the chord diagrams.\n * This class handles drawing guitar chord diagrams with customizable\n * parameters including strings, frets, positions, and styling.\n */\nexport class ChordBox {\n    params: ChordBoxParams;\n    width: number;\n    height: number;\n    numStrings: number;\n    numFrets: number;\n    spacing: number;\n    fretSpacing: number;\n    x: number;\n    y: number;\n    metrics: ChordMetrics;\n    position: number;\n    positionText: number;\n    chord: [number, number | 'x', string?][];\n    barres: Barre[];\n    tuning: string[];\n    drawer?: CanvasDrawer;\n\n    /**\n     * Creates a new ChordBox instance\n     * @param params - Configuration parameters for the chord diagram\n     */\n    constructor(params: ChordBoxParams) {\n        this.params = {\n            ...{\n                numStrings: 6,\n                numFrets: 5,\n                x: 0,\n                y: 0,\n                width: 100,\n                height: 120,\n                strokeWidth: 1,\n                showTuning: true,\n                defaultColor: '#666',\n                bgColor: '#fff',\n                labelColor: '#fff',\n                fontFamily: '-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"',\n                fontSize: undefined,\n                fontStyle: 'light',\n                fontWeight: '100',\n                labelWeight: '100',\n            },\n            ...params,\n        };\n\n        // Setup defaults if not specifically overridden\n        ['bridgeColor', 'stringColor', 'fretColor', 'strokeColor', 'textColor'].forEach((param) => {\n            this.params[param] = this.params[param] || this.params.defaultColor;\n        });\n\n        ['stringWidth', 'fretWidth'].forEach((param) => {\n            this.params[param] = this.params[param] || this.params.strokeWidth;\n        });\n\n        // Size and shift board\n        this.width = this.params.width * 0.75;\n        this.height = this.params.height * 0.75;\n\n        // Initialize scaled-spacing\n        this.numStrings = this.params.numStrings;\n        this.numFrets = this.params.numFrets;\n        this.spacing = this.width / this.numStrings;\n        this.fretSpacing = this.height / (this.numFrets + 2);\n\n        // Add room on sides for finger positions on 1. and 6. string\n        this.x = this.params.x + this.params.width * 0.15 + this.spacing / 2;\n        this.y = this.params.y + this.params.height * 0.15 + this.fretSpacing;\n\n        this.metrics = {\n            circleRadius: this.width / 20,\n            barreRadius: this.width / 25,\n            fontSize: this.params.fontSize || Math.ceil(this.width / 8),\n            barShiftX: this.width / 28,\n            bridgeStrokeWidth: Math.ceil(this.height / 36),\n        };\n\n        // Content\n        this.position = 0;\n        this.positionText = 0;\n        this.chord = [];\n        this.barres = [];\n        this.tuning = ['E', 'A', 'D', 'G', 'B', 'E'];\n    }\n\n    /**\n     * Main method to draw the chord diagram\n     * @param container - A DOM element where the chord diagram will be rendered\n     * @param options - Drawing options\n     */\n    draw(container: HTMLElement, options: ChordDefinition): void {\n        this.drawer = new CanvasDrawer(container, this.params.width, this.params.height);\n\n        this.doDraw(options);\n    }\n\n    /**\n     * Performs the actual drawing of the chord diagram components\n     * @param options - Drawing options\n     */\n    doDraw(options: ChordDefinition): void {\n        const { chord, position, barres, positionText, tuning } = options;\n        \n        this.chord = chord;\n        this.position = position || 0;\n        this.positionText = positionText || 0;\n        this.barres = barres || [];\n        this.tuning = tuning || ['E', 'A', 'D', 'G', 'B', 'E'];\n        \n        if (this.tuning.length === 0) {\n            this.fretSpacing = this.height / (this.numFrets + 1);\n        }\n\n        const { spacing } = this;\n        const { fretSpacing } = this;\n\n        if (this.position <= 1) {\n            // Draw guitar bridge\n            const fromX = this.x - (this.params.strokeWidth / 2);\n            const fromY = this.y - this.metrics.bridgeStrokeWidth;\n            // Draw guitar bridge\n            const bridgeWidth = this.x + spacing * (this.numStrings - 1) - fromX + (this.params.strokeWidth / 2);\n            const bridgeHeight = this.y - fromY;\n            this.drawer.drawRect(fromX, fromY, bridgeWidth, bridgeHeight, {\n                fill: this.params.bridgeColor,\n                stroke: { width: 0 },\n            });\n        } else {\n            // Draw position number\n            this.drawer.drawText(\n                this.x - this.spacing / 2 - this.spacing * 0.1, \n                this.y + this.fretSpacing * this.positionText, \n                this.position.toString(),\n                {\n                    family: this.params.fontFamily,\n                    size: this.metrics.fontSize,\n                    style: this.params.fontStyle,\n                    weight: this.params.fontWeight\n                },\n                {\n                    stroke: this.params.textColor,\n                    fill: this.params.textColor\n                }\n            );\n        }\n\n        // Draw strings\n        for (let i = 0; i < this.numStrings; i += 1) {\n            this.drawer.drawLine(this.x + spacing * i, this.y, this.x + spacing * i, this.y + fretSpacing * this.numFrets).stroke({\n                width: this.params.stringWidth,\n                color: this.params.stringColor,\n            });\n        }\n\n        // Draw frets\n        for (let i = 0; i < this.numFrets + 1; i += 1) {\n            this.drawer.drawLine(this.x, this.y + fretSpacing * i, this.x + spacing * (this.numStrings - 1), this.y + fretSpacing * i).stroke({\n                width: this.params.fretWidth,\n                color: this.params.fretColor,\n            });\n        }\n\n        // Draw tuning keys\n        if (this.params.showTuning && this.tuning.length !== 0) {\n            for (let i = 0; i < Math.min(this.numStrings, this.tuning.length); i += 1) {\n                this.drawer.drawText(\n                    this.x + this.spacing * i, \n                    this.y + this.numFrets * this.fretSpacing + this.fretSpacing / 12, \n                    this.tuning[i],\n                    {\n                        family: this.params.fontFamily,\n                        size: this.metrics.fontSize,\n                        style: this.params.fontStyle,\n                        weight: this.params.fontWeight\n                    },\n                    {\n                        stroke: this.params.textColor,\n                        fill: this.params.textColor\n                    }\n                );\n            }\n        }\n\n        // Draw finger positions\n        for (let i = 0; i < this.chord.length; i += 1) {\n            this.drawFingerPosition({\n                string: this.chord[i][0],\n                fret: this.chord[i][1],\n                label: this.chord.length > 2 ? this.chord[i][2] : undefined,\n            });\n        }\n\n        // Draw barres\n        for (let i = 0; i < this.barres.length; i += 1) {\n            this.drawBarre(this.barres[i].fromString, this.barres[i].toString, this.barres[i].fret);\n        }\n    }\n\n    /**\n     * Draws a finger position on the fretboard\n     * @param options - Finger position options\n     * @returns The ChordBox instance for chaining\n     */\n    drawFingerPosition(options: LightUpParams): this {\n        const { string, fret, label } = options;\n        const stringNum = this.numStrings - string;\n        const shiftPosition = this.position === 1 && this.positionText === 1 ? this.positionText : 0;\n\n        const mute = fret === 'x';\n        const fretNum = fret === 'x' ? 0 : fret - shiftPosition;\n\n        const x = this.x + this.spacing * stringNum;\n        let y = this.y + this.fretSpacing * fretNum;\n\n        if (fretNum === 0) {\n            y -= this.metrics.bridgeStrokeWidth;\n        }\n\n        if (!mute) {\n            this.drawer.drawCircle(\n                x, \n                y - this.fretSpacing / 2, \n                this.params.circleRadius || this.metrics.circleRadius, \n                {\n                    stroke: { color: this.params.strokeColor, width: this.params.strokeWidth },\n                    fill: fretNum > 0 ? this.params.strokeColor : this.params.bgColor\n                }\n            );\n        } else {\n            this.drawer.drawText(\n                x, \n                y - this.fretSpacing, \n                'X',\n                {\n                    family: this.params.fontFamily,\n                    size: this.metrics.fontSize,\n                    style: this.params.fontStyle,\n                    weight: this.params.fontWeight\n                },\n                {\n                    stroke: this.params.textColor,\n                    fill: this.params.textColor\n                }\n            );\n        }\n\n        if (label) {\n            const fontSize = this.metrics.fontSize * 0.55;\n            const textYShift = fontSize * 0.66;\n            this.drawer.drawText(\n                x, \n                y - this.fretSpacing / 2 - textYShift, \n                label, \n                {\n                    family: this.params.fontFamily,\n                    size: fontSize,\n                    style: this.params.fontStyle,\n                    weight: this.params.labelWeight\n                },\n                {\n                    stroke: {\n                        width: 0.7,\n                        color: fretNum !== 0 ? this.params.labelColor : this.params.strokeColor,\n                    },\n                    fill: fretNum !== 0 ? this.params.labelColor : this.params.strokeColor\n                }\n            );\n        }\n\n        return this;\n    }\n\n    /**\n     * Draws a barre (bar chord representation) across multiple strings\n     * @param stringFrom - Starting string number\n     * @param stringTo - Ending string number\n     * @param theFretNum - Fret number where the barre is placed\n     * @returns The ChordBox instance for chaining\n     */\n    drawBarre(stringFrom: number, stringTo: number, theFretNum: number): this {\n        let fretNum = theFretNum;\n        if (this.position === 1 && this.positionText === 1) {\n            fretNum -= this.positionText;\n        }\n\n        const stringFromNum = this.numStrings - stringFrom;\n        const stringToNum = this.numStrings - stringTo;\n\n        const x = this.x + this.spacing * stringFromNum - this.metrics.barShiftX;\n        const xTo = this.x + this.spacing * stringToNum + this.metrics.barShiftX;\n\n        const y = this.y + this.fretSpacing * (fretNum - 1) + this.fretSpacing / 4;\n        const yTo = this.y + this.fretSpacing * (fretNum - 1) + (this.fretSpacing / 4) * 3;\n\n        this.drawer.drawRect(x, y, xTo - x, yTo - y, {\n            fill: this.params.strokeColor,\n            radius: this.metrics.barreRadius,\n        });\n\n        return this;\n    }\n}",
            "src/chorder/drawChord.ts": "import { ChordBox, ChordBoxParams } from './chordbox';\nimport { ChordDefinition } from '@/types';\n\n/**\n * 绘制和弦图的工具函数\n * \n * @param container DOM元素，和弦图将渲染在此元素内\n * @param options ChordBox配置参数\n * @param chordDefinition 和弦定义数据\n * @returns ChordBox实例，允许链式调用\n */\nexport function drawChord(\n  container: HTMLElement,\n  chordDefinition: ChordDefinition,\n  options: ChordBoxParams = {},\n): void {\n  // 创建默认选项\n  const defaultOptions: ChordBoxParams = {\n    numFrets: 4,\n    showTuning: false,\n  };\n\n  // 合并默认选项和用户提供的选项\n  const mergedOptions = { ...defaultOptions, ...options };\n\n  // 创建ChordBox实例\n  const chordBox = new ChordBox(mergedOptions);\n  \n  // 提取和弦定义的属性，并提供默认值\n  const { \n    chord,\n    position = 0,\n    barres = [],\n    positionText = position, // 默认与position相同\n    tuning\n  } = chordDefinition;\n  \n  // 绘制和弦图\n  chordBox.draw(container, {\n    chord,\n    position,\n    barres,\n    positionText,\n    tuning\n  });\n}",
            "src/chorder/index.ts": "export { drawChord } from './drawChord';\nexport { degree_to_name, name_to_degree } from './degree';",
            "src/components/Chord.tsx": "import { useEffect, useRef } from 'react';\nimport { drawChord } from '@/chorder';\nimport { chordData } from '@/data/chords';\n\nconst Chord = ({ name }) => {\n  // 用于获取 DOM 元素的引用，通过 chordRef.current 确认 DOM 元素是否已经挂载\n  const chordRef = useRef(null);\n  // 用于跟踪组件是否已经渲染过\n  const hasRenderedRef = useRef(false); // 添加一个引用来跟踪是否已经渲染过\n  \n  useEffect(() => {\n    // StrictMode 会导致组件渲染两次，如果已经渲染过，则不再重复渲染\n    if (hasRenderedRef.current) {\n      return;\n    }\n    \n    if (!chordRef.current) {\n      // 确保组件挂载后再渲染和弦图\n      console.error('无法渲染和弦图，原因: chordRef.current 为空');\n      return;\n    }\n    if (!chordData[name]) {\n      console.error(`无法渲染和弦图，原因: chordData[\"${name}\"] 不存在`);\n      return;\n    }\n\n    // 绘制和弦图\n    drawChord(chordRef.current, chordData[name]);\n    \n    hasRenderedRef.current = true; // 标记为已渲染\n    \n  }, [name]);\n\n  return (\n    <div className=\"flex flex-col gap-0 items-center\">\n        <div className=\"w-[100px] h-[120px] flex justify-center items-center\" ref={chordRef}></div>\n        <div className=\"font-sans text-sm text-gray-500 text-center mt-auto\">{name}</div>\n    </div>\n  );\n};\n\nexport default Chord;",
            "src/components/ChordInput.tsx": "import { useState, useEffect } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport { degree_to_name, name_to_degree } from '@/chorder';\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { Select, SelectContent, SelectGroup, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\";\nimport { useChordContext } from '@/contexts/ChordContext';\nimport { Button } from './ui/button';\nimport { useToast } from '@/hooks/use-toast';\nimport { LucideIcon, Music, SwitchCamera, Trash2, ClipboardCopy, SquareDashedBottomCode } from 'lucide-react';\n\nconst InputTypeEnum = {\n    DEGREE: 'degree',\n    NAME: 'name'\n};\n\nconst GenericSelect = ({ \n    value, \n    onValueChange, \n    options, \n    placeholder,\n    className = \"\",\n    icon: Icon\n}: { \n    value: string, \n    onValueChange: (value: string) => void, \n    options: {value: string, label: string}[],\n    placeholder: string,\n    className?: string,\n    icon?: LucideIcon\n}) => {\n    return (\n        <Select \n            value={value}\n            onValueChange={onValueChange}\n        >\n            <SelectTrigger className={`w-auto ${className}`}>\n                {Icon && <Icon className=\"mr-2 h-4 w-4\" />}\n                <SelectValue placeholder={placeholder} />\n            </SelectTrigger>\n            <SelectContent>\n                <SelectGroup>\n                    {options.map(option => (\n                        <SelectItem key={option.value} value={option.value}>\n                            {option.label}\n                        </SelectItem>\n                    ))}\n                </SelectGroup>\n            </SelectContent>\n        </Select>\n    );\n};\n\nconst ChordPresetSelect = ({ onPresetSelected }: { onPresetSelected: (preset: string) => void }) => {\n    const { t } = useTranslation();\n    \n    const availableChordPresets = [\n        { value: '1 6 4 5', label: t('chordPresets.1645') },\n        { value: '1 6 2 5', label: t('chordPresets.1625') },\n        { value: '1 5 6 3 4 1 2 5', label: t('chordPresets.canon') },\n        { value: '4 5 3 6 2 5 1', label: t('chordPresets.4536251') },\n        { value: '1 5 6 4', label: t('chordPresets.1564') },\n        { value: '6 4 1 5', label: t('chordPresets.6415') },\n    ];\n    \n    return (\n        <GenericSelect\n            value={''}\n            onValueChange={onPresetSelected}\n            options={availableChordPresets}\n            placeholder={t('chordPresets.placeholder')}\n            icon={SquareDashedBottomCode}\n        />\n    );\n};\n\n\n\nconst ChordInput = () => {\n    const { t } = useTranslation();\n    const [selectedKey, setSelectedKey] = useState('C');\n    const [inputType, setInputType] = useState(InputTypeEnum.DEGREE);\n    const [chordDescription, setChordDescription] = useState('4 5 3 6 2 5 1');\n    const { setChordNames } = useChordContext();\n    const { toast } = useToast();\n    \n    const updateChordNames = (selectedKey: string, inputType: string, chordDescription: string) => {\n        if (!chordDescription.trim()) {\n            setChordNames([]);\n            return;\n        }\n\n        if (inputType === InputTypeEnum.DEGREE) {\n            const degreeChordNames = chordDescription\n                .trim()\n                .split(/\\s+/)\n                .map((degreeChord: string) => degreeChord.trim())\n                .filter((degreeChord: string) => degreeChord !== '');\n            const nameChordNames = degreeChordNames.map((degreeChord: string) => degree_to_name(selectedKey, degreeChord));\n            setChordNames(nameChordNames);\n        } else {\n            const nameChordNames = chordDescription\n                .trim()\n                .split(/\\s+/)\n                .map((nameChord: string) => nameChord.trim())\n                .filter((nameChord: string) => nameChord !== '');\n            setChordNames(nameChordNames);\n        }\n    };\n\n    useEffect(() => {\n        // Initial call to update context with default chord names array\n        updateChordNames(selectedKey, inputType, chordDescription);\n    }, []);\n\n    const handleKeyChange = (key: string) => {\n        setSelectedKey(key);\n        updateChordNames(key, inputType, chordDescription);\n    };\n\n    const handleInputTypeChange = (type: string) => {\n        setInputType(type);\n        let newChordDescription = '';\n        if (type === InputTypeEnum.DEGREE) {\n            newChordDescription = chordDescription\n                .trim()\n                .split(/\\s+/)\n                .map((nameChord: string) => name_to_degree(selectedKey, nameChord))\n                .join(' ');\n        } else {\n            newChordDescription = chordDescription\n                .trim()\n                .split(/\\s+/)\n                .map((degreeChord: string) => degree_to_name(selectedKey, degreeChord))\n                .join(' ');\n        }\n        setChordDescription(newChordDescription);\n        updateChordNames(selectedKey, type, newChordDescription);\n    };\n\n    const handleChordDescriptionChange = (description: string) => {\n        setChordDescription(description);\n        updateChordNames(selectedKey, inputType, description);\n    };\n\n    const handlePresetSelected = (preset: string) => {\n        const newChordDescription = chordDescription + ' ' + preset;\n        setChordDescription(newChordDescription);\n        updateChordNames(selectedKey, inputType, newChordDescription);\n    };\n\n    const handleCopyChordDescription = () => {\n        navigator.clipboard.writeText(chordDescription);\n        toast({\n            description: t('buttons.copySuccess'),\n        });\n    };\n\n    const keyOptions = [\n        { value: 'C', label: t('keySelect.C') },\n        { value: 'G', label: t('keySelect.G') },\n        { value: 'D', label: t('keySelect.D') },\n        { value: 'A', label: t('keySelect.A') },\n        { value: 'E', label: t('keySelect.E') }\n    ];\n\n    const inputTypeOptions = [\n        { value: InputTypeEnum.DEGREE, label: t('inputType.byDegree') },\n        { value: InputTypeEnum.NAME, label: t('inputType.byName') }\n    ];\n\n    return (\n        <div className=\"flex flex-col gap-4\">\n            <div className=\"w-full sm:w-80 flex flex-row gap-2\">\n                {[\n                    {\n                        label: t('keySelect.label'),\n                        value: selectedKey,\n                        onValueChange: handleKeyChange,\n                        options: keyOptions,\n                        placeholder: t('keySelect.placeholder'),\n                        icon: Music\n                    },\n                    {\n                        label: t('inputType.label'),\n                        value: inputType,\n                        onValueChange: handleInputTypeChange,\n                        options: inputTypeOptions,\n                        placeholder: t('inputType.placeholder'),\n                        icon: SwitchCamera,\n                    }\n                ].map((selectConfig, index) => (\n                    <div key={index} className=\"flex flex-1 items-center justify-between\">\n                        <GenericSelect \n                            value={selectConfig.value}\n                            onValueChange={selectConfig.onValueChange}\n                            className='w-full'\n                            options={selectConfig.options}\n                            placeholder={selectConfig.placeholder}\n                            icon={selectConfig.icon}\n                        />\n                    </div>\n                ))}\n            </div>\n            <div className=\"w-full flex justify-center items-center\">\n                <Textarea\n                    className=\"p-2 text-base w-full h-auto min-h-28\"\n                    placeholder={t('textarea.placeholder')}\n                    value={chordDescription} \n                    onChange={(e) => handleChordDescriptionChange(e.target.value)}\n                />\n            </div>\n            <div className=\"flex w-full ml-auto flex-row-reverse gap-2 items-center\">\n                <Button\n                    variant=\"destructive\"\n                    className=\"px-3 h-9 sm:px-4\"\n                    onClick={() => handleChordDescriptionChange('')}\n                >\n                    <Trash2 className=\"h-3.5 w-3.5\" />\n                    <span className=\"hidden sm:inline-block sm:ml-2\">{t('buttons.clear')}</span>\n                </Button>\n                <Button\n                    variant=\"outline\"\n                    className=\"px-3 h-9 sm:px-4\"\n                    onClick={handleCopyChordDescription}\n                >\n                    <ClipboardCopy className=\"h-3.5 w-3.5\" />\n                    <span className=\"hidden sm:inline-block sm:ml-2\">{t('buttons.copy')}</span>\n                </Button>\n                <ChordPresetSelect \n                    onPresetSelected={handlePresetSelected}\n                />\n            </div>\n            \n        </div>\n    );\n};\n\nexport default ChordInput;",
            "src/types/index.ts": "/**\n * 类型定义索引文件\n */\n\nexport * from './chord';"
        },
        "deleted_files": [
            "src/chorder/builder.js",
            "src/types/chordbox.ts",
            "src/types/components.ts",
            "src/types/context.ts"
        ]
    }
]
