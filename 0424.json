[
    {
        "commit_message": "refactor chordbox.js",
        "added_files": {},
        "modified_files": {
            "src/chorder/chordbox.js": "import {SVG} from '@svgdotjs/svg.js';\n\n/**\n * CanvasDrawer implements low-level canvas drawing operations\n * It encapsulates the SVG.js operations to provide a simplified interface\n */\nclass CanvasDrawer {\n    /**\n     * Creates a new CanvasDrawer instance\n     * @param {HTMLElement} container - A DOM element where the diagram will be rendered\n     * @param {number} width - Original width of the canvas\n     * @param {number} height - Original height of the canvas\n     */\n    constructor(container, width, height) {\n        this.canvas = this.createCanvas(container, width, height);\n    }\n\n    /**\n     * Creates the SVG canvas element and configures its initial properties\n     * @param {HTMLElement} container - A DOM element where the diagram will be rendered\n     * @param {number} width - Original width of the canvas\n     * @param {number} height - Original height of the canvas\n     * @returns {SVG} - The SVG canvas element\n     */\n    createCanvas(container, width, height) {\n        // Create canvas and add it to the DOM\n        const canvas = SVG()\n            .addTo(container)\n            .size(width, height)\n            .viewbox(0, 0, width, height)\n            .attr('preserveAspectRatio', 'xMidYMid meet');\n\n        // Scale according to parent container size, and center\n        const parentHeight = container.clientHeight;\n        const parentWidth = container.clientWidth;\n        const scaleFactor = Math.min(parentHeight / height, parentWidth / width);\n\n        canvas.scale(scaleFactor);\n        canvas.translate((parentWidth - width) / 2, (parentHeight - height) / 2);\n\n        return canvas;\n    }\n\n    /**\n     * Draws text on the canvas\n     * @param {number} x - X coordinate\n     * @param {number} y - Y coordinate\n     * @param {string} msg - Text message to display\n     * @param {Object} font - Text font options (must include family, size, style, weight)\n     * @param {Object} options - Required styling options\n     * @param {string|Object} options.stroke - Color string or stroke options object\n     * @param {string} options.fill - Fill color\n     * @returns {Object} - The text element object\n     */\n    drawText(x, y, msg, font, options) {\n        const text = this.canvas\n            .text(`${msg}`)\n            .font(font)\n            .stroke(options.stroke)\n            .fill(options.fill);\n\n        return text.move(x - text.length() / 2, y);\n    }\n\n    /**\n     * Draws a line on the canvas\n     * @param {number} x - Starting X coordinate\n     * @param {number} y - Starting Y coordinate\n     * @param {number} newX - Ending X coordinate\n     * @param {number} newY - Ending Y coordinate\n     * @returns {Object} - The line element object\n     */\n    drawLine(x, y, newX, newY) {\n        return this.canvas\n            .line(0, 0, newX - x, newY - y)\n            .move(x, y);\n    }\n\n    /**\n     * Draws a rectangle on the canvas\n     * @param {number} x - X coordinate\n     * @param {number} y - Y coordinate\n     * @param {number} width - Rectangle width\n     * @param {number} height - Rectangle height\n     * @param {Object} options - Optional styling options\n     * @param {string} options.fill - Fill color\n     * @param {Object} options.stroke - Stroke options (e.g., { width: 1, color: '#000' })\n     * @param {number} options.radius - Corner radius\n     * @returns {Object} - The rectangle element object\n     */\n    drawRect(x, y, width, height, options = {}) {\n        const rect = this.canvas\n            .rect(width, height)\n            .move(x, y);\n        if (options.fill) {\n            rect.fill(options.fill);\n        }\n        if (options.stroke) {\n            rect.stroke(options.stroke);\n        }\n        if (options.radius) {\n            rect.radius(options.radius);\n        }\n        return rect;\n    }\n\n    /**\n     * Draws a circle on the canvas\n     * @param {number} x - X coordinate of the center\n     * @param {number} y - Y coordinate of the center\n     * @param {number} radius - Circle radius\n     * @param {Object} options - Optional styling options\n     * @param {string} options.fill - Fill color\n     * @param {Object} options.stroke - Stroke options (e.g., { width: 1, color: '#000' })\n     * @returns {Object} - The circle element object\n     */\n    drawCircle(x, y, radius, options = {}) {\n        const circle = this.canvas\n            .circle()\n            .move(x, y)\n            .radius(radius);\n        if (options.fill) {\n            circle.fill(options.fill);\n        }\n        if (options.stroke) {\n            circle.stroke(options.stroke);\n        }\n        return circle;\n    }\n}\n\n/**\n * ChordBox implements the rendering logic for the chord diagrams.\n * This class handles drawing guitar chord diagrams with customizable\n * parameters including strings, frets, positions, and styling.\n */\nclass ChordBox {\n    /**\n     * Creates a new ChordBox instance\n     * @param {Object} params - Configuration parameters for the chord diagram\n     */\n    constructor(params) {\n        this.params = {\n            ...{\n                numStrings: 6,\n                numFrets: 5,\n                x: 0,\n                y: 0,\n                width: 100,\n                height: 120,\n                strokeWidth: 1,\n                showTuning: true,\n                defaultColor: '#666',\n                bgColor: '#fff',\n                labelColor: '#fff',\n                fontFamily: '-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"',\n                fontSize: undefined,\n                fontStyle: 'light',\n                fontWeight: '100',\n                labelWeight: '100',\n            },\n            ...params,\n        };\n\n        // Setup defaults if not specifically overridden\n        ['bridgeColor', 'stringColor', 'fretColor', 'strokeColor', 'textColor'].forEach((param) => {\n            this.params[param] = this.params[param] || this.params.defaultColor;\n        });\n\n        ['stringWidth', 'fretWidth'].forEach((param) => {\n            this.params[param] = this.params[param] || this.params.strokeWidth;\n        });\n\n        // Size and shift board\n        this.width = this.params.width * 0.75;\n        this.height = this.params.height * 0.75;\n\n        // Initialize scaled-spacing\n        this.numStrings = this.params.numStrings;\n        this.numFrets = this.params.numFrets;\n        this.spacing = this.width / this.numStrings;\n        this.fretSpacing = this.height / (this.numFrets + 2);\n\n        // Add room on sides for finger positions on 1. and 6. string\n        this.x = this.params.x + this.params.width * 0.15 + this.spacing / 2;\n        this.y = this.params.y + this.params.height * 0.15 + this.fretSpacing;\n\n        this.metrics = {\n            circleRadius: this.width / 20,\n            barreRadius: this.width / 25,\n            fontSize: this.params.fontSize || Math.ceil(this.width / 8),\n            barShiftX: this.width / 28,\n            bridgeStrokeWidth: Math.ceil(this.height / 36),\n        };\n\n        // Content\n        this.position = 0;\n        this.positionText = 0;\n        this.chord = [];\n        this.barres = [];\n        this.tuning = ['E', 'A', 'D', 'G', 'B', 'E'];\n    }\n\n    /**\n     * Main method to draw the chord diagram\n     * @param {HTMLElement} container - A DOM element where the chord diagram will be rendered\n     * @param {Object} options - Drawing options\n     * @param {Array} options.chord - Array of chord fingerings [[string, fret, label], ...]\n     * @param {number} options.position - Fret position (for shifted chord diagrams)\n     * @param {Array} options.barres - Array of barre chord definitions\n     * @param {number} options.positionText - Text position indicator\n     * @param {Array} options.tuning - Array of string tuning labels\n     */\n    draw(container, { chord, position, barres, positionText, tuning }) {\n        this.drawer = new CanvasDrawer(container, this.params.width, this.params.height);\n\n        this.doDraw({\n            chord, position, barres, positionText, tuning,\n        });\n    }\n\n    /**\n     * Performs the actual drawing of the chord diagram components\n     * @param {Object} options - Drawing options\n     * @param {Array} options.chord - Array of chord fingerings\n     * @param {number} options.position - Fret position\n     * @param {Array} options.barres - Array of barre chord definitions\n     * @param {number} options.positionText - Text position indicator\n     * @param {Array} options.tuning - Array of string tuning labels\n     */\n    doDraw({ chord, position, barres, positionText, tuning }) {\n        this.chord = chord;\n        this.position = position || 0;\n        this.positionText = positionText || 0;\n        this.barres = barres || [];\n        this.tuning = tuning || ['E', 'A', 'D', 'G', 'B', 'E'];\n        if (this.tuning.length === 0) {\n            this.fretSpacing = this.height / (this.numFrets + 1);\n        }\n\n        const { spacing } = this;\n        const { fretSpacing } = this;\n\n        if (this.position <= 1) {\n            // Draw guitar bridge\n            const fromX = this.x - (this.params.strokeWidth / 2);\n            const fromY = this.y - this.metrics.bridgeStrokeWidth;\n            // Draw guitar bridge\n            const bridgeWidth = this.x + spacing * (this.numStrings - 1) - fromX + (this.params.strokeWidth / 2);\n            const bridgeHeight = this.y - fromY;\n            this.drawer.drawRect(fromX, fromY, bridgeWidth, bridgeHeight, {\n                fill: this.params.bridgeColor,\n                stroke: { width: 0 },\n            });\n        } else {\n            // Draw position number\n            this.drawer.drawText(\n                this.x - this.spacing / 2 - this.spacing * 0.1, \n                this.y + this.fretSpacing * this.positionText, \n                this.position,\n                {\n                    family: this.params.fontFamily,\n                    size: this.metrics.fontSize,\n                    style: this.params.fontStyle,\n                    weight: this.params.fontWeight\n                },\n                {\n                    stroke: this.params.textColor,\n                    fill: this.params.textColor\n                }\n            );\n        }\n\n        // Draw strings\n        for (let i = 0; i < this.numStrings; i += 1) {\n            this.drawer.drawLine(this.x + spacing * i, this.y, this.x + spacing * i, this.y + fretSpacing * this.numFrets).stroke({\n                width: this.params.stringWidth,\n                color: this.params.stringColor,\n            });\n        }\n\n        // Draw frets\n        for (let i = 0; i < this.numFrets + 1; i += 1) {\n            this.drawer.drawLine(this.x, this.y + fretSpacing * i, this.x + spacing * (this.numStrings - 1), this.y + fretSpacing * i).stroke({\n                width: this.params.fretWidth,\n                color: this.params.fretColor,\n            });\n        }\n\n        // Draw tuning keys\n        if (this.params.showTuning && this.tuning.length !== 0) {\n            for (let i = 0; i < Math.min(this.numStrings, this.tuning.length); i += 1) {\n                this.drawer.drawText(\n                    this.x + this.spacing * i, \n                    this.y + this.numFrets * this.fretSpacing + this.fretSpacing / 12, \n                    this.tuning[i],\n                    {\n                        family: this.params.fontFamily,\n                        size: this.metrics.fontSize,\n                        style: this.params.fontStyle,\n                        weight: this.params.fontWeight\n                    },\n                    {\n                        stroke: this.params.textColor,\n                        fill: this.params.textColor\n                    }\n                );\n            }\n        }\n\n        // Draw finger positions\n        for (let i = 0; i < this.chord.length; i += 1) {\n            this.drawFingerPosition({\n                string: this.chord[i][0],\n                fret: this.chord[i][1],\n                label: this.chord.length > 2 ? this.chord[i][2] : undefined,\n            });\n        }\n\n        // Draw barres\n        for (let i = 0; i < this.barres.length; i += 1) {\n            this.drawBarre(this.barres[i].fromString, this.barres[i].toString, this.barres[i].fret);\n        }\n    }\n\n    /**\n     * Draws a finger position on the fretboard\n     * @param {Object} options - Finger position options\n     * @param {number} options.string - String number (1-6, where 1 is the highest pitched string)\n     * @param {number|string} options.fret - Fret number or 'x' for muted string\n     * @param {string} options.label - Optional label to display inside the finger position\n     * @returns {Object} - The ChordBox instance for chaining\n     */\n    drawFingerPosition({ string, fret, label }) {\n        const stringNum = this.numStrings - string;\n        const shiftPosition = this.position === 1 && this.positionText === 1 ? this.positionText : 0;\n\n        const mute = fret === 'x';\n        const fretNum = fret === 'x' ? 0 : fret - shiftPosition;\n\n        const x = this.x + this.spacing * stringNum;\n        let y = this.y + this.fretSpacing * fretNum;\n\n        if (fretNum === 0) {\n            y -= this.metrics.bridgeStrokeWidth;\n        }\n\n        if (!mute) {\n            this.drawer.drawCircle(\n                x, \n                y - this.fretSpacing / 2, \n                this.params.circleRadius || this.metrics.circleRadius, \n                {\n                    stroke: { color: this.params.strokeColor, width: this.params.strokeWidth },\n                    fill: fretNum > 0 ? this.params.strokeColor : this.params.bgColor\n                }\n            );\n        } else {\n            this.drawer.drawText(\n                x, \n                y - this.fretSpacing, \n                'X',\n                {\n                    family: this.params.fontFamily,\n                    size: this.metrics.fontSize,\n                    style: this.params.fontStyle,\n                    weight: this.params.fontWeight\n                },\n                {\n                    stroke: this.params.textColor,\n                    fill: this.params.textColor\n                }\n            );\n        }\n\n        if (label) {\n            const fontSize = this.metrics.fontSize * 0.55;\n            const textYShift = fontSize * 0.66;\n            this.drawer.drawText(\n                x, \n                y - this.fretSpacing / 2 - textYShift, \n                label, \n                {\n                    family: this.params.fontFamily,\n                    size: fontSize,\n                    style: this.params.fontStyle,\n                    weight: this.params.labelWeight\n                },\n                {\n                    stroke: {\n                        width: 0.7,\n                        color: fretNum !== 0 ? this.params.labelColor : this.params.strokeColor,\n                    },\n                    fill: fretNum !== 0 ? this.params.labelColor : this.params.strokeColor\n                }\n            );\n        }\n\n        return this;\n    }\n\n    /**\n     * Draws a barre (bar chord representation) across multiple strings\n     * @param {number} stringFrom - Starting string number\n     * @param {number} stringTo - Ending string number\n     * @param {number} theFretNum - Fret number where the barre is placed\n     * @returns {Object} - The ChordBox instance for chaining\n     */\n    drawBarre(stringFrom, stringTo, theFretNum) {\n        let fretNum = theFretNum;\n        if (this.position === 1 && this.positionText === 1) {\n            fretNum -= this.positionText;\n        }\n\n        const stringFromNum = this.numStrings - stringFrom;\n        const stringToNum = this.numStrings - stringTo;\n\n        const x = this.x + this.spacing * stringFromNum - this.metrics.barShiftX;\n        const xTo = this.x + this.spacing * stringToNum + this.metrics.barShiftX;\n\n        const y = this.y + this.fretSpacing * (fretNum - 1) + this.fretSpacing / 4;\n        const yTo = this.y + this.fretSpacing * (fretNum - 1) + (this.fretSpacing / 4) * 3;\n\n        this.drawer.drawRect(x, y, xTo - x, yTo - y, {\n            fill: this.params.strokeColor,\n            radius: this.metrics.barreRadius,\n        });\n\n        return this;\n    }\n}\n\nexport {ChordBox};"
        },
        "deleted_files": []
    },
    {
        "commit_message": "migrate chordbox to ts",
        "added_files": {
            "src/chorder/chordbox.ts": "import {SVG, Svg, Text, Line, Rect, Circle, StrokeData} from '@svgdotjs/svg.js';\nimport { ChordBoxParams, LightUpParams, TextAttrs } from '@/types';\nimport { ChordDefinition, Barre } from '@/types';\n\n/**\n * Font options for text rendering\n */\ninterface FontOptions {\n    family: string;\n    size: number;\n    style: string;\n    weight: string;\n}\n\n/**\n * Text drawing options\n */\ninterface TextOptions {\n    stroke: string | StrokeData;\n    fill: string;\n}\n\n/**\n * Rectangle drawing options\n */\ninterface RectOptions {\n    fill?: string;\n    stroke?: StrokeData;\n    radius?: number;\n}\n\n/**\n * Circle drawing options\n */\ninterface CircleOptions {\n    fill?: string;\n    stroke?: StrokeData;\n}\n\n/**\n * Canvas metrics\n */\ninterface ChordMetrics {\n    circleRadius: number;\n    barreRadius: number;\n    fontSize: number;\n    barShiftX: number;\n    bridgeStrokeWidth: number;\n}\n\n/**\n * CanvasDrawer implements low-level canvas drawing operations\n * It encapsulates the SVG.js operations to provide a simplified interface\n */\nclass CanvasDrawer {\n    canvas: Svg;\n\n    /**\n     * Creates a new CanvasDrawer instance\n     * @param container - A DOM element where the diagram will be rendered\n     * @param width - Original width of the canvas\n     * @param height - Original height of the canvas\n     */\n    constructor(container: HTMLElement, width: number, height: number) {\n        this.canvas = this.createCanvas(container, width, height);\n    }\n\n    /**\n     * Creates the SVG canvas element and configures its initial properties\n     * @param container - A DOM element where the diagram will be rendered\n     * @param width - Original width of the canvas\n     * @param height - Original height of the canvas\n     * @returns The SVG canvas element\n     */\n    createCanvas(container: HTMLElement, width: number, height: number): Svg {\n        // Create canvas and add it to the DOM\n        const canvas = SVG()\n            .addTo(container)\n            .size(width, height)\n            .viewbox(0, 0, width, height)\n            .attr('preserveAspectRatio', 'xMidYMid meet');\n\n        // Scale according to parent container size, and center\n        const parentHeight = container.clientHeight;\n        const parentWidth = container.clientWidth;\n        const scaleFactor = Math.min(parentHeight / height, parentWidth / width);\n\n        canvas.scale(scaleFactor);\n        canvas.translate((parentWidth - width) / 2, (parentHeight - height) / 2);\n\n        return canvas;\n    }\n\n    /**\n     * Draws text on the canvas\n     * @param x - X coordinate\n     * @param y - Y coordinate\n     * @param msg - Text message to display\n     * @param font - Text font options (must include family, size, style, weight)\n     * @param options - Required styling options\n     * @returns The text element object\n     */\n    drawText(x: number, y: number, msg: string, font: FontOptions, options: TextOptions): Text {\n        const text = this.canvas\n            .text(`${msg}`)\n            .font(font);\n            \n        // Handle different types of stroke parameter\n        if (typeof options.stroke === 'string') {\n            text.stroke(options.stroke as string);\n        } else {\n            text.stroke(options.stroke as StrokeData);\n        }\n        \n        text.fill(options.fill);\n\n        return text.move(x - text.length() / 2, y);\n    }\n\n    /**\n     * Draws a line on the canvas\n     * @param x - Starting X coordinate\n     * @param y - Starting Y coordinate\n     * @param newX - Ending X coordinate\n     * @param newY - Ending Y coordinate\n     * @returns The line element object\n     */\n    drawLine(x: number, y: number, newX: number, newY: number): Line {\n        return this.canvas\n            .line(0, 0, newX - x, newY - y)\n            .move(x, y);\n    }\n\n    /**\n     * Draws a rectangle on the canvas\n     * @param x - X coordinate\n     * @param y - Y coordinate\n     * @param width - Rectangle width\n     * @param height - Rectangle height\n     * @param options - Optional styling options\n     * @returns The rectangle element object\n     */\n    drawRect(x: number, y: number, width: number, height: number, options: RectOptions = {}): Rect {\n        const rect = this.canvas\n            .rect(width, height)\n            .move(x, y);\n        if (options.fill) {\n            rect.fill(options.fill);\n        }\n        if (options.stroke) {\n            rect.stroke(options.stroke);\n        }\n        if (options.radius) {\n            rect.radius(options.radius);\n        }\n        return rect;\n    }\n\n    /**\n     * Draws a circle on the canvas\n     * @param x - X coordinate of the center\n     * @param y - Y coordinate of the center\n     * @param radius - Circle radius\n     * @param options - Optional styling options\n     * @returns The circle element object\n     */\n    drawCircle(x: number, y: number, radius: number, options: CircleOptions = {}): Circle {\n        const circle = this.canvas\n            .circle()\n            .move(x, y)\n            .radius(radius);\n        if (options.fill) {\n            circle.fill(options.fill);\n        }\n        if (options.stroke) {\n            circle.stroke(options.stroke);\n        }\n        return circle;\n    }\n}\n\n/**\n * ChordBox implements the rendering logic for the chord diagrams.\n * This class handles drawing guitar chord diagrams with customizable\n * parameters including strings, frets, positions, and styling.\n */\nexport class ChordBox {\n    params: ChordBoxParams;\n    width: number;\n    height: number;\n    numStrings: number;\n    numFrets: number;\n    spacing: number;\n    fretSpacing: number;\n    x: number;\n    y: number;\n    metrics: ChordMetrics;\n    position: number;\n    positionText: number;\n    chord: [number, number | 'x', string?][];\n    barres: Barre[];\n    tuning: string[];\n    drawer?: CanvasDrawer;\n\n    /**\n     * Creates a new ChordBox instance\n     * @param params - Configuration parameters for the chord diagram\n     */\n    constructor(params: ChordBoxParams) {\n        this.params = {\n            ...{\n                numStrings: 6,\n                numFrets: 5,\n                x: 0,\n                y: 0,\n                width: 100,\n                height: 120,\n                strokeWidth: 1,\n                showTuning: true,\n                defaultColor: '#666',\n                bgColor: '#fff',\n                labelColor: '#fff',\n                fontFamily: '-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"',\n                fontSize: undefined,\n                fontStyle: 'light',\n                fontWeight: '100',\n                labelWeight: '100',\n            },\n            ...params,\n        };\n\n        // Setup defaults if not specifically overridden\n        ['bridgeColor', 'stringColor', 'fretColor', 'strokeColor', 'textColor'].forEach((param) => {\n            this.params[param] = this.params[param] || this.params.defaultColor;\n        });\n\n        ['stringWidth', 'fretWidth'].forEach((param) => {\n            this.params[param] = this.params[param] || this.params.strokeWidth;\n        });\n\n        // Size and shift board\n        this.width = this.params.width * 0.75;\n        this.height = this.params.height * 0.75;\n\n        // Initialize scaled-spacing\n        this.numStrings = this.params.numStrings;\n        this.numFrets = this.params.numFrets;\n        this.spacing = this.width / this.numStrings;\n        this.fretSpacing = this.height / (this.numFrets + 2);\n\n        // Add room on sides for finger positions on 1. and 6. string\n        this.x = this.params.x + this.params.width * 0.15 + this.spacing / 2;\n        this.y = this.params.y + this.params.height * 0.15 + this.fretSpacing;\n\n        this.metrics = {\n            circleRadius: this.width / 20,\n            barreRadius: this.width / 25,\n            fontSize: this.params.fontSize || Math.ceil(this.width / 8),\n            barShiftX: this.width / 28,\n            bridgeStrokeWidth: Math.ceil(this.height / 36),\n        };\n\n        // Content\n        this.position = 0;\n        this.positionText = 0;\n        this.chord = [];\n        this.barres = [];\n        this.tuning = ['E', 'A', 'D', 'G', 'B', 'E'];\n    }\n\n    /**\n     * Main method to draw the chord diagram\n     * @param container - A DOM element where the chord diagram will be rendered\n     * @param options - Drawing options\n     */\n    draw(container: HTMLElement, options: ChordDefinition): void {\n        this.drawer = new CanvasDrawer(container, this.params.width, this.params.height);\n\n        this.doDraw(options);\n    }\n\n    /**\n     * Performs the actual drawing of the chord diagram components\n     * @param options - Drawing options\n     */\n    doDraw(options: ChordDefinition): void {\n        const { chord, position, barres, positionText, tuning } = options;\n        \n        this.chord = chord;\n        this.position = position || 0;\n        this.positionText = positionText || 0;\n        this.barres = barres || [];\n        this.tuning = tuning || ['E', 'A', 'D', 'G', 'B', 'E'];\n        \n        if (this.tuning.length === 0) {\n            this.fretSpacing = this.height / (this.numFrets + 1);\n        }\n\n        const { spacing } = this;\n        const { fretSpacing } = this;\n\n        if (this.position <= 1) {\n            // Draw guitar bridge\n            const fromX = this.x - (this.params.strokeWidth / 2);\n            const fromY = this.y - this.metrics.bridgeStrokeWidth;\n            // Draw guitar bridge\n            const bridgeWidth = this.x + spacing * (this.numStrings - 1) - fromX + (this.params.strokeWidth / 2);\n            const bridgeHeight = this.y - fromY;\n            this.drawer.drawRect(fromX, fromY, bridgeWidth, bridgeHeight, {\n                fill: this.params.bridgeColor,\n                stroke: { width: 0 },\n            });\n        } else {\n            // Draw position number\n            this.drawer.drawText(\n                this.x - this.spacing / 2 - this.spacing * 0.1, \n                this.y + this.fretSpacing * this.positionText, \n                this.position.toString(),\n                {\n                    family: this.params.fontFamily,\n                    size: this.metrics.fontSize,\n                    style: this.params.fontStyle,\n                    weight: this.params.fontWeight\n                },\n                {\n                    stroke: this.params.textColor,\n                    fill: this.params.textColor\n                }\n            );\n        }\n\n        // Draw strings\n        for (let i = 0; i < this.numStrings; i += 1) {\n            this.drawer.drawLine(this.x + spacing * i, this.y, this.x + spacing * i, this.y + fretSpacing * this.numFrets).stroke({\n                width: this.params.stringWidth,\n                color: this.params.stringColor,\n            });\n        }\n\n        // Draw frets\n        for (let i = 0; i < this.numFrets + 1; i += 1) {\n            this.drawer.drawLine(this.x, this.y + fretSpacing * i, this.x + spacing * (this.numStrings - 1), this.y + fretSpacing * i).stroke({\n                width: this.params.fretWidth,\n                color: this.params.fretColor,\n            });\n        }\n\n        // Draw tuning keys\n        if (this.params.showTuning && this.tuning.length !== 0) {\n            for (let i = 0; i < Math.min(this.numStrings, this.tuning.length); i += 1) {\n                this.drawer.drawText(\n                    this.x + this.spacing * i, \n                    this.y + this.numFrets * this.fretSpacing + this.fretSpacing / 12, \n                    this.tuning[i],\n                    {\n                        family: this.params.fontFamily,\n                        size: this.metrics.fontSize,\n                        style: this.params.fontStyle,\n                        weight: this.params.fontWeight\n                    },\n                    {\n                        stroke: this.params.textColor,\n                        fill: this.params.textColor\n                    }\n                );\n            }\n        }\n\n        // Draw finger positions\n        for (let i = 0; i < this.chord.length; i += 1) {\n            this.drawFingerPosition({\n                string: this.chord[i][0],\n                fret: this.chord[i][1],\n                label: this.chord.length > 2 ? this.chord[i][2] : undefined,\n            });\n        }\n\n        // Draw barres\n        for (let i = 0; i < this.barres.length; i += 1) {\n            this.drawBarre(this.barres[i].fromString, this.barres[i].toString, this.barres[i].fret);\n        }\n    }\n\n    /**\n     * Draws a finger position on the fretboard\n     * @param options - Finger position options\n     * @returns The ChordBox instance for chaining\n     */\n    drawFingerPosition(options: LightUpParams): this {\n        const { string, fret, label } = options;\n        const stringNum = this.numStrings - string;\n        const shiftPosition = this.position === 1 && this.positionText === 1 ? this.positionText : 0;\n\n        const mute = fret === 'x';\n        const fretNum = fret === 'x' ? 0 : fret - shiftPosition;\n\n        const x = this.x + this.spacing * stringNum;\n        let y = this.y + this.fretSpacing * fretNum;\n\n        if (fretNum === 0) {\n            y -= this.metrics.bridgeStrokeWidth;\n        }\n\n        if (!mute) {\n            this.drawer.drawCircle(\n                x, \n                y - this.fretSpacing / 2, \n                this.params.circleRadius || this.metrics.circleRadius, \n                {\n                    stroke: { color: this.params.strokeColor, width: this.params.strokeWidth },\n                    fill: fretNum > 0 ? this.params.strokeColor : this.params.bgColor\n                }\n            );\n        } else {\n            this.drawer.drawText(\n                x, \n                y - this.fretSpacing, \n                'X',\n                {\n                    family: this.params.fontFamily,\n                    size: this.metrics.fontSize,\n                    style: this.params.fontStyle,\n                    weight: this.params.fontWeight\n                },\n                {\n                    stroke: this.params.textColor,\n                    fill: this.params.textColor\n                }\n            );\n        }\n\n        if (label) {\n            const fontSize = this.metrics.fontSize * 0.55;\n            const textYShift = fontSize * 0.66;\n            this.drawer.drawText(\n                x, \n                y - this.fretSpacing / 2 - textYShift, \n                label, \n                {\n                    family: this.params.fontFamily,\n                    size: fontSize,\n                    style: this.params.fontStyle,\n                    weight: this.params.labelWeight\n                },\n                {\n                    stroke: {\n                        width: 0.7,\n                        color: fretNum !== 0 ? this.params.labelColor : this.params.strokeColor,\n                    },\n                    fill: fretNum !== 0 ? this.params.labelColor : this.params.strokeColor\n                }\n            );\n        }\n\n        return this;\n    }\n\n    /**\n     * Draws a barre (bar chord representation) across multiple strings\n     * @param stringFrom - Starting string number\n     * @param stringTo - Ending string number\n     * @param theFretNum - Fret number where the barre is placed\n     * @returns The ChordBox instance for chaining\n     */\n    drawBarre(stringFrom: number, stringTo: number, theFretNum: number): this {\n        let fretNum = theFretNum;\n        if (this.position === 1 && this.positionText === 1) {\n            fretNum -= this.positionText;\n        }\n\n        const stringFromNum = this.numStrings - stringFrom;\n        const stringToNum = this.numStrings - stringTo;\n\n        const x = this.x + this.spacing * stringFromNum - this.metrics.barShiftX;\n        const xTo = this.x + this.spacing * stringToNum + this.metrics.barShiftX;\n\n        const y = this.y + this.fretSpacing * (fretNum - 1) + this.fretSpacing / 4;\n        const yTo = this.y + this.fretSpacing * (fretNum - 1) + (this.fretSpacing / 4) * 3;\n\n        this.drawer.drawRect(x, y, xTo - x, yTo - y, {\n            fill: this.params.strokeColor,\n            radius: this.metrics.barreRadius,\n        });\n\n        return this;\n    }\n}",
            "src/chorder/index.ts": "// Re-export from chordbox.ts\nexport { ChordBox } from './chordbox';\nexport { drawChord } from './drawChord';"
        },
        "modified_files": {
            "src/components/Chord.tsx": "import { useEffect, useRef } from 'react';\nimport { drawChord } from '@/chorder/drawChord';\nimport { chordData } from '@/data/chords';\n\nconst Chord = ({ name }) => {\n  // 用于获取 DOM 元素的引用，通过 chordRef.current 确认 DOM 元素是否已经挂载\n  const chordRef = useRef(null);\n  // 用于跟踪组件是否已经渲染过\n  const hasRenderedRef = useRef(false); // 添加一个引用来跟踪是否已经渲染过\n  \n  useEffect(() => {\n    // StrictMode 会导致组件渲染两次，如果已经渲染过，则不再重复渲染\n    if (hasRenderedRef.current) {\n      return;\n    }\n    \n    if (!chordRef.current) {\n      // 确保组件挂载后再渲染和弦图\n      console.error('无法渲染和弦图，原因: chordRef.current 为空');\n      return;\n    }\n    if (!chordData[name]) {\n      console.error(`无法渲染和弦图，原因: chordData[\"${name}\"] 不存在`);\n      return;\n    }\n\n    // 绘制和弦图\n    drawChord(chordRef.current, chordData[name]);\n    \n    hasRenderedRef.current = true; // 标记为已渲染\n    \n  }, [name]);\n\n  return (\n    <div className=\"flex flex-col gap-0 items-center\">\n        <div className=\"w-[100px] h-[120px] flex justify-center items-center\" ref={chordRef}></div>\n        <div className=\"font-sans text-sm text-gray-500 text-center mt-auto\">{name}</div>\n    </div>\n  );\n};\n\nexport default Chord;"
        },
        "deleted_files": [
            "src/chorder/chordbox.js",
            "src/types/declarations.d.ts"
        ]
    },
    {
        "commit_message": "responsive",
        "added_files": {},
        "modified_files": {
            "index.html": "<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Guitar Chord Generator</title>\n</head>\n<body>\n\n\n<div id=\"root\"></div>\n<script type=\"module\" src=\"/src/index.jsx\"></script>\n</body>\n</html>",
            "src/components/ChordInput.tsx": "import { useState, useEffect } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport { degree_to_name, name_to_degree } from '@/chorder/degree';\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { Select, SelectContent, SelectGroup, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\";\nimport { useChordContext } from '@/contexts/ChordContext';\nimport { Button } from './ui/button';\nimport { useToast } from '@/hooks/use-toast';\nimport { LucideIcon, Music, SwitchCamera, Trash2, ClipboardCopy, SquareDashedBottomCode } from 'lucide-react';\n\nconst InputTypeEnum = {\n    DEGREE: 'degree',\n    NAME: 'name'\n};\n\nconst GenericSelect = ({ \n    value, \n    onValueChange, \n    options, \n    placeholder,\n    className = \"w-auto\",\n    icon: Icon\n}: { \n    value: string, \n    onValueChange: (value: string) => void, \n    options: {value: string, label: string}[],\n    placeholder: string,\n    className?: string,\n    icon?: LucideIcon\n}) => {\n    return (\n        <Select \n            value={value}\n            onValueChange={onValueChange}\n        >\n            <SelectTrigger className={`${className}`}>\n                {Icon && <Icon className=\"mr-2 h-4 w-4\" />}\n                <SelectValue placeholder={placeholder} />\n            </SelectTrigger>\n            <SelectContent>\n                <SelectGroup>\n                    {options.map(option => (\n                        <SelectItem key={option.value} value={option.value}>\n                            {option.label}\n                        </SelectItem>\n                    ))}\n                </SelectGroup>\n            </SelectContent>\n        </Select>\n    );\n};\n\nconst ChordPresetSelect = ({ onPresetSelected }: { onPresetSelected: (preset: string) => void }) => {\n    const { t } = useTranslation();\n    \n    const availableChordPresets = [\n        { value: '1 6 4 5', label: t('chordPresets.1645') },\n        { value: '1 6 2 5', label: t('chordPresets.1625') },\n        { value: '1 5 6 3 4 1 2 5', label: t('chordPresets.canon') },\n        { value: '4 5 3 6 2 5 1', label: t('chordPresets.4536251') },\n        { value: '1 5 6 4', label: t('chordPresets.1564') },\n        { value: '6 4 1 5', label: t('chordPresets.6415') },\n    ];\n    \n    return (\n        <GenericSelect\n            value={''}\n            onValueChange={onPresetSelected}\n            options={availableChordPresets}\n            placeholder={t('chordPresets.placeholder')}\n            icon={SquareDashedBottomCode}\n        />\n    );\n};\n\n\n\nconst ChordInput = () => {\n    const { t } = useTranslation();\n    const [selectedKey, setSelectedKey] = useState('C');\n    const [inputType, setInputType] = useState(InputTypeEnum.DEGREE);\n    const [chordDescription, setChordDescription] = useState('4 5 3 6 2 5 1');\n    const { setChordNames } = useChordContext();\n    const { toast } = useToast();\n    \n    const updateChordNames = (selectedKey: string, inputType: string, chordDescription: string) => {\n        if (!chordDescription.trim()) {\n            setChordNames([]);\n            return;\n        }\n\n        if (inputType === InputTypeEnum.DEGREE) {\n            const degreeChordNames = chordDescription\n                .trim()\n                .split(/\\s+/)\n                .map((degreeChord: string) => degreeChord.trim())\n                .filter((degreeChord: string) => degreeChord !== '');\n            const nameChordNames = degreeChordNames.map((degreeChord: string) => degree_to_name(selectedKey, degreeChord));\n            setChordNames(nameChordNames);\n        } else {\n            const nameChordNames = chordDescription\n                .trim()\n                .split(/\\s+/)\n                .map((nameChord: string) => nameChord.trim())\n                .filter((nameChord: string) => nameChord !== '');\n            setChordNames(nameChordNames);\n        }\n    };\n\n    useEffect(() => {\n        // Initial call to update context with default chord names array\n        updateChordNames(selectedKey, inputType, chordDescription);\n    }, []);\n\n    const handleKeyChange = (key: string) => {\n        setSelectedKey(key);\n        updateChordNames(key, inputType, chordDescription);\n    };\n\n    const handleInputTypeChange = (type: string) => {\n        setInputType(type);\n        let newChordDescription = '';\n        if (type === InputTypeEnum.DEGREE) {\n            newChordDescription = chordDescription\n                .trim()\n                .split(/\\s+/)\n                .map((nameChord: string) => name_to_degree(selectedKey, nameChord))\n                .join(' ');\n        } else {\n            newChordDescription = chordDescription\n                .trim()\n                .split(/\\s+/)\n                .map((degreeChord: string) => degree_to_name(selectedKey, degreeChord))\n                .join(' ');\n        }\n        setChordDescription(newChordDescription);\n        updateChordNames(selectedKey, type, newChordDescription);\n    };\n\n    const handleChordDescriptionChange = (description: string) => {\n        setChordDescription(description);\n        updateChordNames(selectedKey, inputType, description);\n    };\n\n    const handlePresetSelected = (preset: string) => {\n        const newChordDescription = chordDescription + ' ' + preset;\n        setChordDescription(newChordDescription);\n        updateChordNames(selectedKey, inputType, newChordDescription);\n    };\n\n    const handleCopyChordDescription = () => {\n        navigator.clipboard.writeText(chordDescription);\n        toast({\n            description: t('buttons.copySuccess'),\n        });\n    };\n\n    const keyOptions = [\n        { value: 'C', label: t('keySelect.C') },\n        { value: 'G', label: t('keySelect.G') },\n        { value: 'D', label: t('keySelect.D') },\n        { value: 'A', label: t('keySelect.A') },\n        { value: 'E', label: t('keySelect.E') }\n    ];\n\n    const inputTypeOptions = [\n        { value: InputTypeEnum.DEGREE, label: t('inputType.byDegree') },\n        { value: InputTypeEnum.NAME, label: t('inputType.byName') }\n    ];\n\n    return (\n        <div className=\"flex flex-col gap-4\">\n            <div className=\"w-full sm:w-80 flex flex-row gap-2\">\n                {[\n                    {\n                        label: t('keySelect.label'),\n                        value: selectedKey,\n                        onValueChange: handleKeyChange,\n                        options: keyOptions,\n                        placeholder: t('keySelect.placeholder'),\n                        icon: Music\n                    },\n                    {\n                        label: t('inputType.label'),\n                        value: inputType,\n                        onValueChange: handleInputTypeChange,\n                        options: inputTypeOptions,\n                        placeholder: t('inputType.placeholder'),\n                        icon: SwitchCamera,\n                    }\n                ].map((selectConfig, index) => (\n                    <div key={index} className=\"flex flex-1 items-center justify-between\">\n                        <GenericSelect \n                            value={selectConfig.value}\n                            onValueChange={selectConfig.onValueChange}\n                            className='w-full'\n                            options={selectConfig.options}\n                            placeholder={selectConfig.placeholder}\n                            icon={selectConfig.icon}\n                        />\n                    </div>\n                ))}\n            </div>\n            <div className=\"w-full flex justify-center items-center\">\n                <Textarea\n                    className=\"p-2 text-base w-full h-auto min-h-28\"\n                    placeholder={t('textarea.placeholder')}\n                    value={chordDescription} \n                    onChange={(e) => handleChordDescriptionChange(e.target.value)}\n                />\n            </div>\n            <div className=\"flex w-full ml-auto flex-row-reverse gap-2 items-center\">\n                <Button\n                    variant=\"destructive\"\n                    className=\"px-3 h-9 sm:px-4\"\n                    onClick={() => handleChordDescriptionChange('')}\n                >\n                    <Trash2 className=\"h-3.5 w-3.5\" />\n                    <span className=\"hidden sm:inline-block sm:ml-2\">{t('buttons.clear')}</span>\n                </Button>\n                <Button\n                    variant=\"outline\"\n                    className=\"px-3 h-9 sm:px-4\"\n                    onClick={handleCopyChordDescription}\n                >\n                    <ClipboardCopy className=\"h-3.5 w-3.5\" />\n                    <span className=\"hidden sm:inline-block sm:ml-2\">{t('buttons.copy')}</span>\n                </Button>\n                <ChordPresetSelect \n                    onPresetSelected={handlePresetSelected}\n                />\n            </div>\n            \n        </div>\n    );\n};\n\nexport default ChordInput;",
            "src/i18n/locales/en.json": "{\n  \"appTitle\": \"Guitar Chord Generator\",\n  \"keySelect\": {\n    \"placeholder\": \"Select Key\",\n    \"C\": \"C Major\",\n    \"G\": \"G Major\",\n    \"D\": \"D Major\",\n    \"A\": \"A Major\",\n    \"E\": \"E Major\",\n    \"label\": \"Key\"\n  },\n  \"inputType\": {\n    \"byDegree\": \"By Degrees\",\n    \"byName\": \"By Names\",\n    \"placeholder\": \"Input Type\",\n    \"label\": \"Input Type\"\n  },\n  \"buttons\": {\n    \"clear\": \"Clear\",\n    \"copy\": \"Copy\",\n    \"copySuccess\": \"Copied to clipboard\"\n  },\n  \"chordPresets\": {\n    \"placeholder\": \"Insert Chord Preset\",\n    \"1645\": \"1645\",\n    \"1625\": \"1625\",\n    \"canon\": \"15634125 (Canon)\",\n    \"4536251\": \"4536251\",\n    \"1564\": \"1564\",\n    \"6415\": \"6415\"\n  },\n  \"textarea\": {\n    \"placeholder\": \"Enter chords, e.g.: 4 5 3 6 2 5 1\"\n  },\n  \"language\": \"Language\",\n  \"switchLang\": {\n    \"en\": \"English\",\n    \"zh\": \"中文\"\n  }\n}",
            "src/i18n/locales/zh.json": "{\n  \"appTitle\": \"吉他和弦生成器\",\n  \"keySelect\": {\n    \"placeholder\": \"选择调式\",\n    \"C\": \"C大调\",\n    \"G\": \"G大调\",\n    \"D\": \"D大调\",\n    \"A\": \"A大调\",\n    \"E\": \"E大调\",\n    \"label\": \"调式\"\n  },\n  \"inputType\": {\n    \"byDegree\": \"级数形式\",\n    \"byName\": \"名称形式\",\n    \"placeholder\": \"输入类型\",\n    \"label\": \"输入类型\"\n  },\n  \"buttons\": {\n    \"clear\": \"清空\",\n    \"copy\": \"复制\",\n    \"copySuccess\": \"已复制到剪贴板\"\n  },\n  \"chordPresets\": {\n    \"placeholder\": \"插入和弦预设\",\n    \"1645\": \"1645\",\n    \"1625\": \"1625\",\n    \"canon\": \"15634125 (卡农)\",\n    \"4536251\": \"4536251\",\n    \"1564\": \"1564\",\n    \"6415\": \"6415\"\n  },\n  \"textarea\": {\n    \"placeholder\": \"请输入和弦，如：4 5 3 6 2 5 1\"\n  },\n  \"language\": \"语言\",\n  \"switchLang\": {\n    \"en\": \"English\",\n    \"zh\": \"中文\"\n  }\n}"
        },
        "deleted_files": []
    },
    {
        "commit_message": "responsive 2",
        "added_files": {},
        "modified_files": {
            "src/App.tsx": "import React from 'react';\nimport { useTranslation } from 'react-i18next';\nimport { Guitar } from 'lucide-react';\nimport ChordOutput from '@/components/ChordOutput';\nimport ChordInput from '@/components/ChordInput';\nimport LanguageSwitcher from '@/components/LanguageSwitcher';\nimport { ChordProvider } from '@/contexts/ChordContext';\nimport { Toaster } from \"@/components/ui/toaster\";\n\nconst App = () => {\n    const { t } = useTranslation();\n    \n    return (\n        <ChordProvider>\n            <div className=\"max-w-4xl mx-auto\">\n                <div className=\"flex flex-col mb-2\">\n                    <div className=\"mx-5 my-3 flex justify-between items-center \">\n                        <div className=\"flex items-center gap-2\">\n                            <Guitar className=\"h-6 w-6\" />\n                            <h1 className=\"text-2xl font-bold\">{t('appTitle')}</h1>\n                        </div>\n                        <LanguageSwitcher />\n                    </div>\n                    <div className=\"h-px bg-gray-200 w-full\"></div>\n                </div>\n                <div className=\"p-4 mx-auto space-y-6\">\n                    <ChordInput />\n                    <div className=\"h-px bg-gray-200 w-full\"></div>\n                    <ChordOutput />\n                </div>\n            </div>\n            <Toaster />\n        </ChordProvider>\n    );\n};\n\nexport default App;",
            "src/components/ChordInput.tsx": "import { useState, useEffect } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport { degree_to_name, name_to_degree } from '@/chorder/degree';\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { Select, SelectContent, SelectGroup, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\";\nimport { useChordContext } from '@/contexts/ChordContext';\nimport { Button } from './ui/button';\nimport { useToast } from '@/hooks/use-toast';\nimport { LucideIcon, Music, SwitchCamera, Trash2, ClipboardCopy, SquareDashedBottomCode } from 'lucide-react';\n\nconst InputTypeEnum = {\n    DEGREE: 'degree',\n    NAME: 'name'\n};\n\nconst GenericSelect = ({ \n    value, \n    onValueChange, \n    options, \n    placeholder,\n    className = \"\",\n    icon: Icon\n}: { \n    value: string, \n    onValueChange: (value: string) => void, \n    options: {value: string, label: string}[],\n    placeholder: string,\n    className?: string,\n    icon?: LucideIcon\n}) => {\n    return (\n        <Select \n            value={value}\n            onValueChange={onValueChange}\n        >\n            <SelectTrigger className={`w-auto ${className}`}>\n                {Icon && <Icon className=\"mr-2 h-4 w-4\" />}\n                <SelectValue placeholder={placeholder} />\n            </SelectTrigger>\n            <SelectContent>\n                <SelectGroup>\n                    {options.map(option => (\n                        <SelectItem key={option.value} value={option.value}>\n                            {option.label}\n                        </SelectItem>\n                    ))}\n                </SelectGroup>\n            </SelectContent>\n        </Select>\n    );\n};\n\nconst ChordPresetSelect = ({ onPresetSelected }: { onPresetSelected: (preset: string) => void }) => {\n    const { t } = useTranslation();\n    \n    const availableChordPresets = [\n        { value: '1 6 4 5', label: t('chordPresets.1645') },\n        { value: '1 6 2 5', label: t('chordPresets.1625') },\n        { value: '1 5 6 3 4 1 2 5', label: t('chordPresets.canon') },\n        { value: '4 5 3 6 2 5 1', label: t('chordPresets.4536251') },\n        { value: '1 5 6 4', label: t('chordPresets.1564') },\n        { value: '6 4 1 5', label: t('chordPresets.6415') },\n    ];\n    \n    return (\n        <GenericSelect\n            value={''}\n            onValueChange={onPresetSelected}\n            options={availableChordPresets}\n            placeholder={t('chordPresets.placeholder')}\n            icon={SquareDashedBottomCode}\n        />\n    );\n};\n\n\n\nconst ChordInput = () => {\n    const { t } = useTranslation();\n    const [selectedKey, setSelectedKey] = useState('C');\n    const [inputType, setInputType] = useState(InputTypeEnum.DEGREE);\n    const [chordDescription, setChordDescription] = useState('4 5 3 6 2 5 1');\n    const { setChordNames } = useChordContext();\n    const { toast } = useToast();\n    \n    const updateChordNames = (selectedKey: string, inputType: string, chordDescription: string) => {\n        if (!chordDescription.trim()) {\n            setChordNames([]);\n            return;\n        }\n\n        if (inputType === InputTypeEnum.DEGREE) {\n            const degreeChordNames = chordDescription\n                .trim()\n                .split(/\\s+/)\n                .map((degreeChord: string) => degreeChord.trim())\n                .filter((degreeChord: string) => degreeChord !== '');\n            const nameChordNames = degreeChordNames.map((degreeChord: string) => degree_to_name(selectedKey, degreeChord));\n            setChordNames(nameChordNames);\n        } else {\n            const nameChordNames = chordDescription\n                .trim()\n                .split(/\\s+/)\n                .map((nameChord: string) => nameChord.trim())\n                .filter((nameChord: string) => nameChord !== '');\n            setChordNames(nameChordNames);\n        }\n    };\n\n    useEffect(() => {\n        // Initial call to update context with default chord names array\n        updateChordNames(selectedKey, inputType, chordDescription);\n    }, []);\n\n    const handleKeyChange = (key: string) => {\n        setSelectedKey(key);\n        updateChordNames(key, inputType, chordDescription);\n    };\n\n    const handleInputTypeChange = (type: string) => {\n        setInputType(type);\n        let newChordDescription = '';\n        if (type === InputTypeEnum.DEGREE) {\n            newChordDescription = chordDescription\n                .trim()\n                .split(/\\s+/)\n                .map((nameChord: string) => name_to_degree(selectedKey, nameChord))\n                .join(' ');\n        } else {\n            newChordDescription = chordDescription\n                .trim()\n                .split(/\\s+/)\n                .map((degreeChord: string) => degree_to_name(selectedKey, degreeChord))\n                .join(' ');\n        }\n        setChordDescription(newChordDescription);\n        updateChordNames(selectedKey, type, newChordDescription);\n    };\n\n    const handleChordDescriptionChange = (description: string) => {\n        setChordDescription(description);\n        updateChordNames(selectedKey, inputType, description);\n    };\n\n    const handlePresetSelected = (preset: string) => {\n        const newChordDescription = chordDescription + ' ' + preset;\n        setChordDescription(newChordDescription);\n        updateChordNames(selectedKey, inputType, newChordDescription);\n    };\n\n    const handleCopyChordDescription = () => {\n        navigator.clipboard.writeText(chordDescription);\n        toast({\n            description: t('buttons.copySuccess'),\n        });\n    };\n\n    const keyOptions = [\n        { value: 'C', label: t('keySelect.C') },\n        { value: 'G', label: t('keySelect.G') },\n        { value: 'D', label: t('keySelect.D') },\n        { value: 'A', label: t('keySelect.A') },\n        { value: 'E', label: t('keySelect.E') }\n    ];\n\n    const inputTypeOptions = [\n        { value: InputTypeEnum.DEGREE, label: t('inputType.byDegree') },\n        { value: InputTypeEnum.NAME, label: t('inputType.byName') }\n    ];\n\n    return (\n        <div className=\"flex flex-col gap-4\">\n            <div className=\"w-full sm:w-80 flex flex-row gap-2\">\n                {[\n                    {\n                        label: t('keySelect.label'),\n                        value: selectedKey,\n                        onValueChange: handleKeyChange,\n                        options: keyOptions,\n                        placeholder: t('keySelect.placeholder'),\n                        icon: Music\n                    },\n                    {\n                        label: t('inputType.label'),\n                        value: inputType,\n                        onValueChange: handleInputTypeChange,\n                        options: inputTypeOptions,\n                        placeholder: t('inputType.placeholder'),\n                        icon: SwitchCamera,\n                    }\n                ].map((selectConfig, index) => (\n                    <div key={index} className=\"flex flex-1 items-center justify-between\">\n                        <GenericSelect \n                            value={selectConfig.value}\n                            onValueChange={selectConfig.onValueChange}\n                            className='w-full'\n                            options={selectConfig.options}\n                            placeholder={selectConfig.placeholder}\n                            icon={selectConfig.icon}\n                        />\n                    </div>\n                ))}\n            </div>\n            <div className=\"w-full flex justify-center items-center\">\n                <Textarea\n                    className=\"p-2 text-base w-full h-auto min-h-28\"\n                    placeholder={t('textarea.placeholder')}\n                    value={chordDescription} \n                    onChange={(e) => handleChordDescriptionChange(e.target.value)}\n                />\n            </div>\n            <div className=\"flex w-full ml-auto flex-row-reverse gap-2 items-center\">\n                <Button\n                    variant=\"destructive\"\n                    className=\"px-3 h-9 sm:px-4\"\n                    onClick={() => handleChordDescriptionChange('')}\n                >\n                    <Trash2 className=\"h-3.5 w-3.5\" />\n                    <span className=\"hidden sm:inline-block sm:ml-2\">{t('buttons.clear')}</span>\n                </Button>\n                <Button\n                    variant=\"outline\"\n                    className=\"px-3 h-9 sm:px-4\"\n                    onClick={handleCopyChordDescription}\n                >\n                    <ClipboardCopy className=\"h-3.5 w-3.5\" />\n                    <span className=\"hidden sm:inline-block sm:ml-2\">{t('buttons.copy')}</span>\n                </Button>\n                <ChordPresetSelect \n                    onPresetSelected={handlePresetSelected}\n                />\n            </div>\n            \n        </div>\n    );\n};\n\nexport default ChordInput;",
            "src/components/LanguageSwitcher.tsx": "import React from 'react';\nimport { useTranslation } from 'react-i18next';\nimport { Select, SelectContent, SelectGroup, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\";\nimport { Languages } from \"lucide-react\";\n\nconst LanguageSwitcher = () => {\n  const { t, i18n } = useTranslation();\n  \n  const changeLanguage = (lng) => {\n    i18n.changeLanguage(lng);\n  };\n\n  return (\n    <Select\n      value={i18n.language}\n      onValueChange={changeLanguage}\n    >\n      <SelectTrigger className=\"w-auto min-w-0 px-2\">\n        <Languages className=\"h-5 w-5\" />\n        <span className=\"sr-only\">{i18n.language === 'en' ? t('switchLang.en') : t('switchLang.zh')}</span>\n      </SelectTrigger>\n      <SelectContent>\n        <SelectGroup>\n          <SelectItem value=\"en\">{t('switchLang.en')}</SelectItem>\n          <SelectItem value=\"zh\">{t('switchLang.zh')}</SelectItem>\n        </SelectGroup>\n      </SelectContent>\n    </Select>\n  );\n};\n\nexport default LanguageSwitcher;"
        },
        "deleted_files": []
    }
]
